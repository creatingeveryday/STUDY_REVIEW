# HTTP
간략하게 정리. 다 정리해보고나서 책을 더 사서 읽어보고 추가로 정리해봐야겠다. 
참고: 모든 개발자를 위한 HTTP 웹 기본 지식

```
< 추가로 읽어볼 책 >
그림으로 공부하는 TCP/IP
IT엔지니어를 위한 네트워크 입문
리얼월드 HTTP
HTTP 완벽가이드	
```

- OSI 7계층
- 인터넷 네트워크
	- 인터넷  통신
		- 클라이언트 - 인터넷 - 서버
		- 인터넷 프로토콜(Internet Protocol, IP)의 역할 : 부여받은 IP 주소로 패킷(Packet)이라는 통신 단위로 데이터를 전달 
		- IP 패킷 정보 구성(출발지 주소, 목적지 주소, 데이터...)하여 클라이언트가 요청하고 서버가 응답을 보낸다.
		- IP 프로토콜의 한계 
			- 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷을 전송한다.
			- 비신뢰성 : 중간에 패킷이 사라질 수 있고 그 사실을 모른다. 패킷이 순서대로 오지 않을 수도 있다. 
			- 프로그램 구분 못함 : 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 경우 IP주소만으로는 구분할 수 없는 한계
	
	- 인터넷 프로토콜 스택의 4계층
		- 애플리케이션 계층 : HTTP, FTP 
		- 전송 계층: TCP, UDP			 	
		- 인터넷 계층: IP						
		- 네트워크 인터페이스 계층: 이더넷 프레임
		
		```text
		1. 프로그램에서 메시지 데이터 작성.(애플리케이션)
		2. SOCKET 라이브러리를 통해 전달.(애플리케이션)
		3. 메시지 데이터를 포함시킨 TCP 정보 생성한다.(OS)
		4. TCP 정보를 포함시킨 IP패킷 생성한다.(OS)
		5. 생성된 패킷이 랜카드와 인터넷을 거쳐 서버에 도착.(네트워크 인터페이스) 
		```
	- TCP (Transmission Control Protocol) 전송제어 프로토콜:  출발지 포트, 목적지 포트, 전송 제어, 순서, 검증
		- TCP 특징
		- 연결지향 - TCP 3 way handshake(논리적 연결) : 먼저 연결을 한 뒤에 메시지를 보낸다. 
			- SYN : 접속 요청, ACK: 요청 수락 : 미리 연결을 확보  
		- 데이터 전달 보증 : 패킷이 누락되면 알 수 있다. 
			- 서버로 데이터 전송 후 서버에서 잘 받았다고 응답.
		- 순서 보장
			- 패킷이 잘못된 순서로 도착하면 제대로 된 순서로 다시 보내라고 서버에서 클라이언트에게 재요청
	- UDP (User Datagram Protocol, 사용자 데이터그램 프로토콜)
		- 데이터 전달 및 순서가 보장되지 않음. 단순하지만 빠름. 
		- IP와 거의 같고 PORT나 체크섬 정도만 추가.
		- 그래서 애플리케이션에서 추가 작업 필요.

	- PORT
		- PORT로 같은 IP 내에서 프로세스 구분
		- 0 ~ 65535 할당 가능
		- 0 ~ 1023 이미 사용중인 포트가 많으므로 사용하지 않는 게 좋다.
			- FTP - 20, 21
			- TELNET - 23
			- HTTP - 80
			- HTTPS - 443

	- DNS (Domain Name System)
		- IP는 사람이 기억하기 어렵고 IP 자체가 변경될 수 있어서 전화번호부처럼 DNS가 도메인 명을 IP주소로 변환
	- URI (Uniform Resource Identifier) https://www.ietf.org/rfc/rfc3986.txt
		- Uniform : 리소스를 식별하는 통일된 방식
		- Resource : URI로 식별할 수 있는 모든 자원
		- Identifier : 다른 항목과 구분하는데 필요한 정보
		- URI는 Locaoter , Name 으로 추가로 분류(URL, URN)
			- URL : 리소스가 있는 위치를 지정 
			- URN: 리소스에 이름을 부여
		- URL
			- 프로토콜, 호스트명, 포트번호, 패스, 쿼리파라미터...
				- 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속, 규칙
				- 호스트명: 도메인명이나 IP주소 직접 입력해서 사용
				- 포트: 80, 443 생략
				- 패스: 계층적 구조
				- 쿼리: ?로 시작, &로 추가 가능, 모두 문자형태  (쿼리파라미터, 쿼리스트링) 
				- fragment : [# fragment ] html 내부 북마크 등에서 사용. 서버에 전송하는 정보는 아님

	- 웹 브라우저 요청흐름 
		1. DNS 조회하여 IP 주소 및 포트 정보 확인
		2. 브라우저가 HTTP 요청 메시지 생성 (GET , 패스 정보, HTTP 버전 정보, 호스트 정보...)
		3. SOCKET 라이브러리를 통해 TCP/IP 계층으로 전달
			- TCP/IP 연결 확립
			- 연결 확인 후 TCP/IP 계층으로 데이터 전달
		4. HTTP 메시지를 포함하여 TCP/IP 패킷 생성
		5. 랜카드와 인터넷을 거쳐 서버에 전달
		6. 서버는 HTTP 응답 메시지를 작성하여 클라이언트에게 전달
		7. 클라이언트 측의 웹 브라우저는 받은 결과를 렌더링하여 화면에 표시한다.
- HTTP
	- 개요
		- HyperText Transfer Protocol
		- HTTP 메시지에 모든 것을 담아서 전송하는 시대
		- TEXT, Image, Audio, Video, JSON, XML ...
		- 서버간에 데이터를 주고 받을때도 역시 HTTP 사용
	- HTTP 역사
		- HTTP/0.9 1991년: GET 메서드만 지원, 헤더 없음
		- HTTP/1.0 1996년: 메서드, 헤더 추가됨
		- HTTP/1.1 1997년: 현재 가장 많이 사용. (TCP 기반)
			- 개정: RFC2068 (1997년) -> RFC2616(1999년) -> RFC7230~7235(2014)
		- HTTP/2    2015년: 성능개선 (TCP 기반)
		- HTTP/3   진행중  : TCP 대신 UDP 사용, 성능개선 (UDP 기반)
		
	- HTTP 특징
		- 클라이언트(요청) 서버(응답) 구조 
			- 클라이언트와 서버를 개념적으로 물리적으로 분리하는게 중요하다. 
			- 비즈니스로직과 데이터는 서버쪽에서 처리하고 클라이언트측은 UI와 사용성에 집중한다. 
			- 서로의 분야에 집중하여 서로 독립적으로 진화 발전할 수 있게 된다. 

		- 무상태 프로토콜(Stateless)
			- 서버가 클라이언트의 상태를 보존하지 않는다. 상태를 유지하지 않는 것을 지향함.
			- 갑자기 클라이언트 요청이 증가한다면? 
				- 서버를 대거 투입하여 응답을 처리할 수 있다. (스케일 아웃: 수평확장에 유리)
			- 실무에서는 모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다. 
			- 그래도 최대한 무상태로 설계한다! 
				- 무상태 예) 로그인이 필요없는 단순한 서비스 소개 화면
				- 상태유지 예) 로그인이 필요한 서비스 화면
				- 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지해야함. 
				- 일반적으로 브라우저의 쿠키와 서버의 세션등을 사용해서 상태유지
			- 무상태일 경우 데이터를 서버측에 상태보다 많이 보낼 수 밖에 없는 구조임. 
			- 최대한 stateless로 설계해서 요청이 갑자기 늘어나더라도 서버를 늘려서 대처할 수 있다. 

		- 비연결성
			- TCP/IP 프로토콜은 연결을 유지함. 연결을 유지하는 동안 서버는 서버 자원을 계속 소모한다. 
			- HTTP 프로토콜은 기본적으로 연결을 유지하지 않는 모델로 서로 필요한 것만 주고받고 연결을 끊어버림. 최소한의 자원을 사용하며 서버자원을 효율적으로 사용함
			- 일반적으로 초 단위 이하의 빠른 속도로 응답하기 때문에 실제 서버에서 1초에 동시처리하는 요청은 매우 적음
			- 비연결성의 단점 및 한계
				- 초기 HTTP 에서는 연결과 종료하는 시간이 낭비된다.  
				- 매 요청마다 TCP/IP 연결을 새로 맺어야함. 그만큼 3-way-handshake 시간이 추가됨.
				- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지등 수많은 자원이 함께 다운로드되는 상황에선 비효율적. 
				- 지금은 HTTP 지속 연결(Persistent Connection)로 문제 해결 했고 HTTP/2, HTTP/3에서 더 많은 최적화

		- HTTP 메시지(rfc7230)
			- 시작라인 - 헤더 - 공백라인(CRLF) - 메시지 바디
			- 시작라인(start-line)
				- 요청시 : request-line : method SP(공백) request-target SP HTTP-version CRLF 
					- 예 : (GET /search?q=hi HTTP/1.1)
					- method : get, post, put, delete... 서버가 수행해야할 동작 지정
					- request-target : absolute-path[?query] 절대경로("/")로 시작하는 경로. (다른 유형으로 경로 지정 가능)
				- 응답시 : status-line : HTTP-version SP status-code SP reason-phrase CRLF  
					- 예 : HTTP/1.1 200 OK
					- HTTP 상태코드 : 요청 성공, 실패 등 요청에대한 정보를 나타냄.
						-  200 성공, 400 클라이언트 요청오류, 500 서버 내부 오류
					- 이유 문구 : 사람이 이해할 수 있는 짧은 상태코드 설명 글
			- 헤더(Header)
				- hearder-field  = field-name ":" OWS field-value OWS (OWS는 띄어쓰기 허용을 의미)
					- field-name 은 대소문자 구분 없음
					- 예) Host: www.google.com
					- 예) Content-Type: text/html;charset=UTF-8
				- Header 의 용도
					- HTTP 전송에 필요한 모든 부가 정보. 바디외의 모든 메타정보
					- 바디의 내용, 크기, 압축, 인증, 요청 클라이언트의 정보, 서버 정보, 캐시 관리 정보... 
					- 표준 헤더가 너무 많음. 
					- 필요시 임의의 헤더 추가 가능 
			- 바디(Body)
				- 실제 전송할 데이터
				- HTML문서 ,이미지,영상, JSON... byte로 표현될 수 있는 모든 데이터 전송가능
	-  HTTP 프로토콜은 단순하지만 확장가능하다. 

- HTTP 메서드 작성
	- URI 설계. 어떤게 좋은 URL 설계인가? 리소스를 잘 식별할 수 있게 설계하는 것이 중요하다.
	- 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용을 권장 : member -> members
	- 리소스(명사)와 행위(동사, 메소드)를 분리하여 리소스를 식별하는게 중요하다. 
- 주요 메서드
	- GET : 리소스 조회
		- 서버에 전달할 데이터는 쿼리를 통해서 전달
		- GET으로 오면 캐싱을 하겠다고 서버 간 약속하기도 함. 
	- POST : 요청 데이터 처리. 주로 요청 데이터를 등록함.
		- 메시지 바디를 통해 서버로 요청 데이터 전달, 서버는 전달받은 데이터를 처리, 등록
		- 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스별로 정해야함. 
		- 새 리소스를 생성하고 등록, 요청 데이터를 처리, 다른 메서드로 처리하기 애매한 경우 사용. 
		- 리소스를 기준으로 URI 설계가 애매하면 행위를 포함하여 URI 설계 (컨트롤 URI)
	- PUT : 리소스를 완전히 대체, 해당 리소스가 없으면 생성
		- 클라이언트가 리소스 위치를 알고 URI 지정
	- PATCH: 리소스 부분 변경
		- PATCH를 사용하지 못할 경우 POST 사용
	- DELETE: 리소스 삭제
	- 기타 메서드
		- HEAD : GET과 동일하지만 메시지부분을 제외하고, 상태줄과 헤더만 반환
		- OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명, 주로 CORS에서 사용
		- CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
		- TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행
- HTTP 메서드의 속성
	- 안전(Safe Methods)
		- 호출해도 리소스를 변경하지 않는다.
	- 멱등(Idempotent Methods)
		- 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다. 
		- 서버쪽에서 Timeout 등으로 정상 응답을 못주었을때, 클라이언트가 같은 요청을 다시 해도 되는가의 판단근거가 됨. 
			- POST의 경우 2번 호출하면 다른 결과가 발생한다.
			- GET : 여러번 조회해도 같은 결과 
			- PUT : 여러번 요청해서 대체해도 같은 결과는 똑같다.
			- DELETE : 여러번 요청해서 삭제된 결과는 똑같다.  
		- 자동 복구 매커니즘
		- 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않음.
	- 캐시가능(Cacheable Methods)
		- 응답 결과 리소스를 캐시해서 사용해도 되는가? 
		- GET, HEAD, POST, PATCH : 캐시 가능 
		- 주로 GET, HEAD 정도만 캐시로 사용 : POST, PATCH는 본문 내용까지 캐시 키로 고려해야해서 구현이 쉽지않아서 거의 사용되지 않음

- HTTP 메서드 활용
	- 클라이언트에서 서버로 데이터 전송하는 방식
		- 쿼리파라미터로 전송
			- GET -> 주로 검색 및 정렬
		- 메시지 바디로 전송
			- POST, PUT, PATCH -> 회원가입, 상품 주문, 리소스 등록, 리소스 변경
			- ContentType 
				- application/x-www-form-urlencoded
					- 전송 내용을 url encoding 처리 후 쿼리파라미터 형식으로 전송
					-  key=value&... 
				- multipart/form-data
					- 바운더리로 나누어 여러 컨텐트 타입으로 전송
					- 파일 업로드 같은 바이너리 데이터를 전송할 때 주로 사용
					- 다른 종류의 여러 파일과 폼의 내용을 함께 전송할 수 있다.
	
	- 클라이언트에서 서버로 데이터 전송하는 케이스
		- 정적 데이터 조회 : 이미지, 정적 텍스트 문서
		- 동적 데이터 조회 : 검색, 정렬
		- HTML Form을 통한 데이터 전송
		- HTTP API를 통한 데이터 전송
			- application/json을 주로 사용
			- 서버간 통신
			- 앱 클라이언트: 아이폰, 안드로이드
			- 웹 클라이언트
				- AJAX 통신

- HTTP API 설계 예시
	- POST 기반 등록 - 신규 자원 등록시 
		- 클라이언트는 등록될 리소스의 URI를 모르는 상태이다.
			- 회원 등록: /members -> POST
		- 서버가 새로 등록된 리소스 URI를 생성해준다. 
			- HTTP/1.1 201 Created    
			    Location: /members/100
		- 컬렉션(Collection)
			- 서버가 관리하는 리소스 디렉토리
			- 서버가 리소스의 URI를 생성하고 관리함.
			- 여기서 컬렉션은 /members
			- 대부분 실무에서 POST 기반의 컬렉션 사용함.
		
	- PUT 기반 등록 - 신규자원 등록시
		- 클라이언트가 리소스 URI를 알고 있어야한다. 
			- 파일등록 /files/{filename} -> PUT
			- PUT /files/apple.jpg
		- 클라이언트가 직접 리소스의 URI를 지정한다.
		- 스토어(Store)
			- 클라이언트가 관리하는 리소스 저장소
			- 클라이언트가 리소스의 URI를 알고 관리
			- 여기서 스토어는 /files  
			
	- HTML Form 사용
		- HTML Form은 GET, POST만 지원하므로 제약이 존재.
		- AJAX와 같은 기술을 사용해서 PUT, PATCH, DELETE 를 사용할 수 있음. 
		- 컨트롤 URI
			- GET, POST만 지원해서 제약이 있는 문제를 해결하기 위해 동사로 된 리소스 경로 사용
			- POST의 /new, /edit, /delete 가 컨트롤 URI
			- HTTP 메서드로 해결하기 애매한 경우 사용(실무에서 많이 사용) 
		- /member/new -> GET : 회원 등록 폼 조회 
		- /member/new -> POST : 회원 등록 
		- /member/{id}/edit -> GET : 회원 수정 폼 조회
		- /member/{id}/edit -> POST : 회원 정보 수정
		- /member/{id}/delete -> POST : 회원 정보 삭제 (컨트롤 URI)
		
	- 참고하면 좋은 URI 설계 개념
		- https://restfulapi.net/resource-naming
		- 문서(document)
			- 단일 개념(파일하나, 객체 인스턴스, 데이터베이스 row)
			- /members/100, /files/apple.png
		- 컬렉션(collection)
			- 서버가 관리하는 리소스 디렉터리
			- 서버가 리소스의 URI를 생성하고 관리
			- /members
		- 스토어(store)
			- 클라이언트가 관리하는 자원 저장소
			- 클라이언트가 리소스의 URI를 알고 관리
			- /files
		- 컨트롤러(controller), 컨트롤 URI
			- 복잡한 실무 환경에서는 어려움. 
			- 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
			- 동사를 직접 사용
			- 주문의 상태를 다음 상태로 진행하는 것을 어떻게 url로 설계할까? 
			- POST /orders/{orderNo}/delivery
- HTTP 상태코드
``` 
1xx (Informational) 	: 요청이 수신되어 처리중 (거의 사용되지 않음) 
2xx (Successful) 	: 요청 정상 처리
3xx (Redirection) 	: 요청을 완료하려면 추가 행동이 필요
4xx (Clinet Error) 	: 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
5xx (Server Error) 	: 서버 오류, 서버가 정상 요청을 처리하지 못함. 
```

클라이언트는 인식할수 없는 상태코드를 수신시 상위 상태코드로 해석해서 처리한다. 

- 2xx 성공
	- 200 OK  요청 성공
	- 201 Created 요청 성공 후 새로운 리소스가 생성됨. 생성된 리소스는 Location 헤더 필드로 식별
	- 202 Accepted 요청이 접수되었으나 처리가 아직 완료되지 않음. 배치 처리? 
	- 204 No Content 요청은 성공했지만 응답 페이로드 본문에 보낼 데이터가 없음. 
- 3xx 리다이렉션 : 요청을 완료하기 위해 클라이언트의 추가 조치 필요. 
	- 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동으로이동한다.
	- Redirection의 종류
		- 영구 리다이렉션 : 특정 리소스의 URI 경로가 영구적 이동
			- 원래의 URL을 더 이상 사용안하고 검색엔진도 변경을 인지한다.
			- 301 Moved Permanently
				- 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수도 있음.
			- 308 Permanent Redirect 
				- 리다이렉트시 요청 메서드와 본문유지
		- 일시 리다이렉션 : 리소스의 URI가 일시적으로 변경. 검색엔진에서 URI를 변경하면안됨. 많이 쓰는 방식. 
			- 주문 완료후 주문 내역 화면으로 이동할때? 
			- PRG: Post/Redirect/Get
				- 주문 후 새로고침하여 재주문이 된다면?? 안된다. 
				- POST로 주문후에 주문 결과화면을 GET 메서드로 리다이렉트해서 중복 주문을 막을 수 있다.
				- 사용자의 실수를 방지할 수 있다.
			- 302 Found
				- 리다이렉트 시 요청메서드가 GET으로 변하고, 본문이 제거될 수도 있음. (모호한 표현)
				- 명확한 307, 303을 권장하지만 현실에서는 302로 많이 구현되어있음. 
				- 자동리다이렉션시 GET으로 변해도 되면 302를 사용해도 큰 문제가 없음. 
			- 307 Temporary Redirect 
				- 리다이렉트시 요청 메서드와 본문 유지. 요청 메서드는 변경하면 안된다. 
			- 303 See Other 
				- 리다이렉트시 요청 메서드가 GET으로 변경됨. 
		- 특수 리다이렉션 : 결과 대신 캐시를 사용한다. 
			- 304 Not Modified
				- 캐시를 목적으로 사용한다. 
				- 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 
				- 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트)
				- 304 응답은 메시지 바디를 포함하면 안된다. (로컬 캐시를 사용)
				- 조건부 GET, HEAD 요청시 사용
- 4XX 클라이언트 오류
	- 클라이언트가 잘못된 요청을 보내고 있기 때문에 재시도를 반복해도 계속 실패한다. 
	- 400 Bad Request 
		- 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음
		- 요청구문 오류
		- 백엔드 개발자가 철저하게 벨리데이션해서 클라이언트 측에 잘못된 요청을 보낸거라고 알려줘야한다. 
	- 401 Unauthorized
		- 클라이언트가 해당 리소스에 대한 인증이 필요하다
		- 인증이 되지 않음. Authentication 에 관한 문제. 
		- 401 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명
	- 403 Forbidden
		- 서버가 요청을 이해했지만 승인을 거부함. 
		- 인증은 통과했지만 접근 권한이 불충분한 경우
		- 예를 들어 관리자의 권한이 필요한 리소스에 로그인한 일반 유저가 접근했을때
	- 404 Not Found
		- 요청한 리소스를 찾을 수 없음
		- 요청 리소스가 서버에 없거나
		- 클라이언트가 권한이 부족한 리소스에 접근할때 해당 리소스를 숨기고 싶을때.
- 5XX 서버 오류
	- 서버에 발생한 문제가 해결되면 재시도시 성공할 수 있음
	- 500 Internal Server Error
		- 서버 문제로 오류 발생한 경우
		- 심각한 문제 발생시
	- 503 Service Unavailable 
		- 서비스 일시적 이용불가 (과부하, 예정된 작업). 잠시 요청 처리가 불가능한 상태
		- Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있음

- HTTP 헤더
	- header-field = field-name: OWS field-value OWS
	- 용도 : HTTP전송에 필요한 모든 부가정보를 포함한다. 바디 내용, 크기, 압축, 인증, 캐시 정보...
	- 표준헤더도 종류가 다양하고 임의의 헤더를 추가할 수도 있다.
	- 클라이언트가 선호하는 표현을 헤더에 담아 요청할 수도 있다.(협상) 서버가 우선순위에 따라 응답.
		- Accept: text/*, text/plain, text/plain;format=flowed 	//구체적인 것이 우선
		- Accept-Charset
		- Accept-Encoding
		- Accept-Language: ko-KR;q=1(생략가능),en-US;q=0.8,en;q=0.7    //우선순위  q-Value
		- 