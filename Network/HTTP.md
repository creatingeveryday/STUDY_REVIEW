# HTTP
간략하게 정리. 다 정리해보고나서 책을 더 사서 읽어보고 추가로 정리해봐야겠다. 
참고: 모든 개발자를 위한 HTTP 웹 기본 지식

```
< 추가로 읽어볼 책 >
그림으로 공부하는 TCP/IP
IT엔지니어를 위한 네트워크 입문
리얼월드 HTTP
HTTP 완벽가이드	
```

- OSI 7계층
- 인터넷 네트워크
	- 인터넷  통신
		- 클라이언트 - 인터넷 - 서버
		- 인터넷 프로토콜(Internet Protocol, IP)의 역할 : 부여받은 IP 주소로 패킷(Packet)이라는 통신 단위로 데이터를 전달 
		- IP 패킷 정보 구성(출발지 주소, 목적지 주소, 데이터...)하여 클라이언트가 요청하고 서버가 응답을 보낸다.
		- IP 프로토콜의 한계 
			- 비연결성 : 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷을 전송한다.
			- 비신뢰성 : 중간에 패킷이 사라질 수 있고 그 사실을 모른다. 패킷이 순서대로 오지 않을 수도 있다. 
			- 프로그램 구분 못함 : 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 경우 IP주소만으로는 구분할 수 없는 한계
	
	- 인터넷 프로토콜 스택의 4계층
		- 애플리케이션 계층 : HTTP, FTP 
		- 전송 계층: TCP, UDP			 	
		- 인터넷 계층: IP						
		- 네트워크 인터페이스 계층: 이더넷 프레임
		
		```text
		1. 프로그램에서 메시지 데이터 작성.(애플리케이션)
		2. SOCKET 라이브러리를 통해 전달.(애플리케이션)
		3. 메시지 데이터를 포함시킨 TCP 정보 생성한다.(OS)
		4. TCP 정보를 포함시킨 IP패킷 생성한다.(OS)
		5. 생성된 패킷이 랜카드와 인터넷을 거쳐 서버에 도착.(네트워크 인터페이스) 
		```
	- TCP (Transmission Control Protocol) 전송제어 프로토콜:  출발지 포트, 목적지 포트, 전송 제어, 순서, 검증
		- TCP 특징
		- 연결지향 - TCP 3 way handshake(논리적 연결) : 먼저 연결을 한 뒤에 메시지를 보낸다. 
			- SYN : 접속 요청, ACK: 요청 수락 : 미리 연결을 확보  
		- 데이터 전달 보증 : 패킷이 누락되면 알 수 있다. 
			- 서버로 데이터 전송 후 서버에서 잘 받았다고 응답.
		- 순서 보장
			- 패킷이 잘못된 순서로 도착하면 제대로 된 순서로 다시 보내라고 서버에서 클라이언트에게 재요청
	- UDP (User Datagram Protocol, 사용자 데이터그램 프로토콜)
		- 데이터 전달 및 순서가 보장되지 않음. 단순하지만 빠름. 
		- IP와 거의 같고 PORT나 체크섬 정도만 추가.
		- 그래서 애플리케이션에서 추가 작업 필요.

	- PORT
		- PORT로 같은 IP 내에서 프로세스 구분
		- 0 ~ 65535 할당 가능
		- 0 ~ 1023 이미 사용중인 포트가 많으므로 사용하지 않는 게 좋다.
			- FTP - 20, 21
			- TELNET - 23
			- HTTP - 80
			- HTTPS - 443

	- DNS (Domain Name System)
		- IP는 사람이 기억하기 어렵고 IP 자체가 변경될 수 있어서 전화번호부처럼 DNS가 도메인 명을 IP주소로 변환
	- URI (Uniform Resource Identifier) https://www.ietf.org/rfc/rfc3986.txt
		- Uniform : 리소스를 식별하는 통일된 방식
		- Resource : URI로 식별할 수 있는 모든 자원
		- Identifier : 다른 항목과 구분하는데 필요한 정보
		- URI는 Locaoter , Name 으로 추가로 분류(URL, URN)
			- URL : 리소스가 있는 위치를 지정 
			- URN: 리소스에 이름을 부여
		- URL
			- 프로토콜, 호스트명, 포트번호, 패스, 쿼리파라미터...
				- 프로토콜 : 어떤 방식으로 자원에 접근할 것인가 하는 약속, 규칙
				- 호스트명: 도메인명이나 IP주소 직접 입력해서 사용
				- 포트: 80, 443 생략
				- 패스: 계층적 구조
				- 쿼리: ?로 시작, &로 추가 가능, 모두 문자형태  (쿼리파라미터, 쿼리스트링) 
				- fragment : [# fragment ] html 내부 북마크 등에서 사용. 서버에 전송하는 정보는 아님

	- 웹 브라우저 요청흐름 
		1. DNS 조회하여 IP 주소 및 포트 정보 확인
		2. 브라우저가 HTTP 요청 메시지 생성 (GET , 패스 정보, HTTP 버전 정보, 호스트 정보...)
		3. SOCKET 라이브러리를 통해 TCP/IP 계층으로 전달
			- TCP/IP 연결 확립
			- 연결 확인 후 TCP/IP 계층으로 데이터 전달
		4. HTTP 메시지를 포함하여 TCP/IP 패킷 생성
		5. 랜카드와 인터넷을 거쳐 서버에 전달
		6. 서버는 HTTP 응답 메시지를 작성하여 클라이언트에게 전달
		7. 클라이언트 측의 웹 브라우저는 받은 결과를 렌더링하여 화면에 표시한다.
- HTTP
	- 개요
		- HyperText Transfer Protocol
		- HTTP 메시지에 모든 것을 담아서 전송하는 시대
		- TEXT, Image, Audio, Video, JSON, XML ...
		- 서버간에 데이터를 주고 받을때도 역시 HTTP 사용
	- HTTP 역사
		- HTTP/0.9 1991년: GET 메서드만 지원, 헤더 없음
		- HTTP/1.0 1996년: 메서드, 헤더 추가됨
		- HTTP/1.1 1997년: 현재 가장 많이 사용. (TCP 기반)
			- 개정: RFC2068 (1997년) -> RFC2616(1999년) -> RFC7230~7235(2014)
		- HTTP/2    2015년: 성능개선 (TCP 기반)
		- HTTP/3   진행중  : TCP 대신 UDP 사용, 성능개선 (UDP 기반)
		
	- HTTP 특징
		- 클라이언트(요청) 서버(응답) 구조 
			- 클라이언트와 서버를 개념적으로 물리적으로 분리하는게 중요하다. 
			- 비즈니스로직과 데이터는 서버쪽에서 처리하고 클라이언트측은 UI와 사용성에 집중한다. 
			- 서로의 분야에 집중하여 서로 독립적으로 진화 발전할 수 있게 된다. 

		- 무상태 프로토콜(Stateless)
			- 서버가 클라이언트의 상태를 보존하지 않는다. 상태를 유지하지 않는 것을 지향함.
			- 갑자기 클라이언트 요청이 증가한다면? 
				- 서버를 대거 투입하여 응답을 처리할 수 있다. (스케일 아웃: 수평확장에 유리)
			- 실무에서는 모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다. 
			- 그래도 최대한 무상태로 설계한다! 
				- 무상태 예) 로그인이 필요없는 단순한 서비스 소개 화면
				- 상태유지 예) 로그인이 필요한 서비스 화면
				- 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지해야함. 
				- 일반적으로 브라우저의 쿠키와 서버의 세션등을 사용해서 상태유지
			- 무상태일 경우 데이터를 서버측에 상태보다 많이 보낼 수 밖에 없는 구조임. 
			- 최대한 stateless로 설계해서 요청이 갑자기 늘어나더라도 서버를 늘려서 대처할 수 있다. 

		- 비연결성
			- TCP/IP 프로토콜은 연결을 유지함. 연결을 유지하는 동안 서버는 서버 자원을 계속 소모한다. 
			- HTTP 프로토콜은 기본적으로 연결을 유지하지 않는 모델로 서로 필요한 것만 주고받고 연결을 끊어버림. 최소한의 자원을 사용하며 서버자원을 효율적으로 사용함
			- 일반적으로 초 단위 이하의 빠른 속도로 응답하기 때문에 실제 서버에서 1초에 동시처리하는 요청은 매우 적음
			- 비연결성의 단점 및 한계
				- 초기 HTTP 에서는 연결과 종료하는 시간이 낭비된다.  
				- 매 요청마다 TCP/IP 연결을 새로 맺어야함. 그만큼 3-way-handshake 시간이 추가됨.
				- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지등 수많은 자원이 함께 다운로드되는 상황에선 비효율적. 
				- 지금은 HTTP 지속 연결(Persistent Connection)로 문제 해결 했고 HTTP/2, HTTP/3에서 더 많은 최적화

		- HTTP 메시지(rfc7230)
			- 시작라인 - 헤더 - 공백라인(CRLF) - 메시지 바디
			- 시작라인(start-line)
				- 요청시 : request-line : method SP(공백) request-target SP HTTP-version CRLF 
					- 예 : (GET /search?q=hi HTTP/1.1)
					- method : get, post, put, delete... 서버가 수행해야할 동작 지정
					- request-target : absolute-path[?query] 절대경로("/")로 시작하는 경로. (다른 유형으로 경로 지정 가능)
				- 응답시 : status-line : HTTP-version SP status-code SP reason-phrase CRLF  
					- 예 : HTTP/1.1 200 OK
					- HTTP 상태코드 : 요청 성공, 실패 등 요청에대한 정보를 나타냄.
						-  200 성공, 400 클라이언트 요청오류, 500 서버 내부 오류
					- 이유 문구 : 사람이 이해할 수 있는 짧은 상태코드 설명 글
			- 헤더(Header)
				- hearder-field  = field-name ":" OWS field-value OWS (OWS는 띄어쓰기 허용을 의미)
					- field-name 은 대소문자 구분 없음
					- 예) Host: www.google.com
					- 예) Content-Type: text/html;charset=UTF-8
				- Header 의 용도
					- HTTP 전송에 필요한 모든 부가 정보. 바디외의 모든 메타정보
					- 바디의 내용, 크기, 압축, 인증, 요청 클라이언트의 정보, 서버 정보, 캐시 관리 정보... 
					- 표준 헤더가 너무 많음. 
					- 필요시 임의의 헤더 추가 가능 
			- 바디(Body)
				- 실제 전송할 데이터
				- HTML문서 ,이미지,영상, JSON... byte로 표현될 수 있는 모든 데이터 전송가능
	-  HTTP 프로토콜은 단순하지만 확장가능하다. 

- HTTP 메서드 작성
	- URI 설계. 어떤게 좋은 URL 설계인가? 리소스를 잘 식별할 수 있게 설계하는 것이 중요하다.
	- 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용을 권장 : member -> members
	- 리소스(명사)와 행위(동사, 메소드)를 분리하여 리소스를 식별하는게 중요하다. 
- 주요 메서드
	- GET : 리소스 조회
		- 서버에 전달할 데이터는 쿼리를 통해서 전달
		- GET으로 오면 캐싱을 하겠다고 서버 간 약속하기도 함. 
	- POST : 요청 데이터 처리. 주로 요청 데이터를 등록함.
		- 메시지 바디를 통해 서버로 요청 데이터 전달, 서버는 전달받은 데이터를 처리, 등록
		- 리소스 URI에 POST 요청이 오면 요청 데이터를 어떻게 처리할지 리소스별로 정해야함. 
		- 새 리소스를 생성하고 등록, 요청 데이터를 처리, 다른 메서드로 처리하기 애매한 경우 사용. 
		- 리소스를 기준으로 URI 설계가 애매하면 행위를 포함하여 URI 설계 (컨트롤 URI)
	- PUT : 리소스를 완전히 대체, 해당 리소스가 없으면 생성
		- 클라이언트가 리소스 위치를 알고 URI 지정
	- PATCH: 리소스 부분 변경
		- PATCH를 사용하지 못할 경우 POST 사용
	- DELETE: 리소스 삭제
	- 기타 메서드
		- HEAD : GET과 동일하지만 메시지부분을 제외하고, 상태줄과 헤더만 반환
		- OPTIONS: 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명, 주로 CORS에서 사용
		- CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정
		- TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행
- HTTP 메서드의 속성
	- 안전(Safe Methods)
		- 호출해도 리소스를 변경하지 않는다.
	- 멱등(Idempotent Methods)
		- 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다. 
		- 서버쪽에서 Timeout 등으로 정상 응답을 못주었을때, 클라이언트가 같은 요청을 다시 해도 되는가의 판단근거가 됨. 
			- POST의 경우 2번 호출하면 다른 결과가 발생한다.
			- GET : 여러번 조회해도 같은 결과 
			- PUT : 여러번 요청해서 대체해도 같은 결과는 똑같다.
			- DELETE : 여러번 요청해서 삭제된 결과는 똑같다.  
		- 자동 복구 매커니즘
		- 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않음.
	- 캐시가능(Cacheable Methods)
		- 응답 결과 리소스를 캐시해서 사용해도 되는가? 
		- GET, HEAD, POST, PATCH : 캐시 가능 
		- 주로 GET, HEAD 정도만 캐시로 사용 : POST, PATCH는 본문 내용까지 캐시 키로 고려해야해서 구현이 쉽지않아서 거의 사용되지 않음

- HTTP 메서드 활용
	- 클라이언트에서 서버로 데이터 전송하는 방식
		- 쿼리파라미터로 전송
			- GET -> 주로 검색 및 정렬
		- 메시지 바디로 전송
			- POST, PUT, PATCH -> 회원가입, 상품 주문, 리소스 등록, 리소스 변경
			- ContentType 
				- application/x-www-form-urlencoded
					- 전송 내용을 url encoding 처리 후 쿼리파라미터 형식으로 전송
					-  key=value&... 
				- multipart/form-data
					- 바운더리로 나누어 여러 컨텐트 타입으로 전송
					- 파일 업로드 같은 바이너리 데이터를 전송할 때 주로 사용
					- 다른 종류의 여러 파일과 폼의 내용을 함께 전송할 수 있다.
	
	- 클라이언트에서 서버로 데이터 전송하는 케이스
		- 정적 데이터 조회 : 이미지, 정적 텍스트 문서
		- 동적 데이터 조회 : 검색, 정렬
		- HTML Form을 통한 데이터 전송
		- HTTP API를 통한 데이터 전송
			- application/json을 주로 사용
			- 서버간 통신
			- 앱 클라이언트: 아이폰, 안드로이드
			- 웹 클라이언트
				- AJAX 통신

- HTTP API 설계 예시
	- POST 기반 등록 - 신규 자원 등록시 
		- 클라이언트는 등록될 리소스의 URI를 모르는 상태이다.
			- 회원 등록: /members -> POST
		- 서버가 새로 등록된 리소스 URI를 생성해준다. 
			- HTTP/1.1 201 Created    
			    Location: /members/100
		- 컬렉션(Collection)
			- 서버가 관리하는 리소스 디렉토리
			- 서버가 리소스의 URI를 생성하고 관리함.
			- 여기서 컬렉션은 /members
			- 대부분 실무에서 POST 기반의 컬렉션 사용함.
		
	- PUT 기반 등록 - 신규자원 등록시
		- 클라이언트가 리소스 URI를 알고 있어야한다. 
			- 파일등록 /files/{filename} -> PUT
			- PUT /files/apple.jpg
		- 클라이언트가 직접 리소스의 URI를 지정한다.
		- 스토어(Store)
			- 클라이언트가 관리하는 리소스 저장소
			- 클라이언트가 리소스의 URI를 알고 관리
			- 여기서 스토어는 /files  
			
	- HTML Form 사용
		- HTML Form은 GET, POST만 지원하므로 제약이 존재.
		- AJAX와 같은 기술을 사용해서 PUT, PATCH, DELETE 를 사용할 수 있음. 
		- 컨트롤 URI
			- GET, POST만 지원해서 제약이 있는 문제를 해결하기 위해 동사로 된 리소스 경로 사용
			- POST의 /new, /edit, /delete 가 컨트롤 URI
			- HTTP 메서드로 해결하기 애매한 경우 사용(실무에서 많이 사용) 
		- /member/new -> GET : 회원 등록 폼 조회 
		- /member/new -> POST : 회원 등록 
		- /member/{id}/edit -> GET : 회원 수정 폼 조회
		- /member/{id}/edit -> POST : 회원 정보 수정
		- /member/{id}/delete -> POST : 회원 정보 삭제 (컨트롤 URI)
		
	- 참고하면 좋은 URI 설계 개념
		- https://restfulapi.net/resource-naming
		- 문서(document)
			- 단일 개념(파일하나, 객체 인스턴스, 데이터베이스 row)
			- /members/100, /files/apple.png
		- 컬렉션(collection)
			- 서버가 관리하는 리소스 디렉터리
			- 서버가 리소스의 URI를 생성하고 관리
			- /members
		- 스토어(store)
			- 클라이언트가 관리하는 자원 저장소
			- 클라이언트가 리소스의 URI를 알고 관리
			- /files
		- 컨트롤러(controller), 컨트롤 URI
			- 복잡한 실무 환경에서는 어려움. 
			- 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
			- 동사를 직접 사용
			- 주문의 상태를 다음 상태로 진행하는 것을 어떻게 url로 설계할까? 
			- POST /orders/{orderNo}/delivery
- HTTP 상태코드
``` 
1xx (Informational) 	: 요청이 수신되어 처리중 (거의 사용되지 않음) 
2xx (Successful) 	: 요청 정상 처리
3xx (Redirection) 	: 요청을 완료하려면 추가 행동이 필요
4xx (Clinet Error) 	: 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
5xx (Server Error) 	: 서버 오류, 서버가 정상 요청을 처리하지 못함. 
```

클라이언트는 인식할수 없는 상태코드를 수신시 상위 상태코드로 해석해서 처리한다. 

- 2xx 성공
	- 200 OK  요청 성공
	- 201 Created 요청 성공 후 새로운 리소스가 생성됨. 생성된 리소스는 Location 헤더 필드로 식별
	- 202 Accepted 요청이 접수되었으나 처리가 아직 완료되지 않음. 배치 처리? 
	- 204 No Content 요청은 성공했지만 응답 페이로드 본문에 보낼 데이터가 없음. 
- 3xx 리다이렉션 : 요청을 완료하기 위해 클라이언트의 추가 조치 필요. 
	- 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동으로이동한다.
	- Redirection의 종류
		- 영구 리다이렉션 : 특정 리소스의 URI 경로가 영구적 이동
			- 원래의 URL을 더 이상 사용안하고 검색엔진도 변경을 인지한다.
			- 301 Moved Permanently
				- 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수도 있음.
			- 308 Permanent Redirect 
				- 리다이렉트시 요청 메서드와 본문유지
		- 일시 리다이렉션 : 리소스의 URI가 일시적으로 변경. 검색엔진에서 URI를 변경하면안됨. 많이 쓰는 방식. 
			- 주문 완료후 주문 내역 화면으로 이동할때? 
			- PRG: Post/Redirect/Get
				- 주문 후 새로고침하여 재주문이 된다면?? 안된다. 
				- POST로 주문후에 주문 결과화면을 GET 메서드로 리다이렉트해서 중복 주문을 막을 수 있다.
				- 사용자의 실수를 방지할 수 있다.
			- 302 Found
				- 리다이렉트 시 요청메서드가 GET으로 변하고, 본문이 제거될 수도 있음. (모호한 표현)
				- 명확한 307, 303을 권장하지만 현실에서는 302로 많이 구현되어있음. 
				- 자동리다이렉션시 GET으로 변해도 되면 302를 사용해도 큰 문제가 없음. 
			- 307 Temporary Redirect 
				- 리다이렉트시 요청 메서드와 본문 유지. 요청 메서드는 변경하면 안된다. 
			- 303 See Other 
				- 리다이렉트시 요청 메서드가 GET으로 변경됨. 
		- 특수 리다이렉션 : 결과 대신 캐시를 사용한다. 
			- 304 Not Modified
				- 캐시를 목적으로 사용한다. 
				- 클라이언트에게 리소스가 수정되지 않았음을 알려준다. 
				- 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트)
				- 304 응답은 메시지 바디를 포함하면 안된다. (로컬 캐시를 사용)
				- 조건부 GET, HEAD 요청시 사용
- 4XX 클라이언트 오류
	- 클라이언트가 잘못된 요청을 보내고 있기 때문에 재시도를 반복해도 계속 실패한다. 
	- 400 Bad Request 
		- 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음
		- 요청구문 오류
		- 백엔드 개발자가 철저하게 벨리데이션해서 클라이언트 측에 잘못된 요청을 보낸거라고 알려줘야한다. 
	- 401 Unauthorized
		- 클라이언트가 해당 리소스에 대한 인증이 필요하다
		- 인증이 되지 않음. Authentication 에 관한 문제. 
		- 401 오류 발생시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명
	- 403 Forbidden
		- 서버가 요청을 이해했지만 승인을 거부함. 
		- 인증은 통과했지만 접근 권한이 불충분한 경우
		- 예를 들어 관리자의 권한이 필요한 리소스에 로그인한 일반 유저가 접근했을때
	- 404 Not Found
		- 요청한 리소스를 찾을 수 없음
		- 요청 리소스가 서버에 없거나
		- 클라이언트가 권한이 부족한 리소스에 접근할때 해당 리소스를 숨기고 싶을때.
- 5XX 서버 오류
	- 서버에 발생한 문제가 해결되면 재시도시 성공할 수 있음
	- 500 Internal Server Error
		- 서버 문제로 오류 발생한 경우
		- 심각한 문제 발생시
	- 503 Service Unavailable 
		- 서비스 일시적 이용불가 (과부하, 예정된 작업). 잠시 요청 처리가 불가능한 상태
		- Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수도 있음

- HTTP 헤더
	- header-field = field-name: OWS field-value OWS
	- 용도 : HTTP전송에 필요한 모든 부가정보를 포함한다. 바디 내용, 크기, 압축, 인증, 캐시 정보...
	- 표준헤더도 종류가 다양하고 임의의 헤더를 추가할 수도 있다.
	- 클라이언트가 선호하는 표현을 헤더에 담아 요청할 수도 있다.(협상) 서버가 우선순위에 따라 응답.
		- Accept: text/*, text/plain, text/plain;format=flowed 	//구체적인 것이 우선
		- Accept-Charset
		- Accept-Encoding
		- Accept-Language: ko-KR;q=1(생략가능),en-US;q=0.8,en;q=0.7    //우선순위  q-Value
	- 전송 방식
		- 단순 전송: Content-length 정보 제공
		- 압축 전송: Content-Encoding 정보 제공
		- 분할 전송: Transfer-Encoding: chunked, Content-length 사용하면 안됨. 
		- 범위 전송: Range: bytes=1001-2000, Content-Range: bytes 1001-2000 / 2000 
	- 일반 정보를 다루는 헤더
		- From: 유저 에이전트의 이메일 정보, 검색엔진에서 주로 사용, 요청시 사용
		- Referer: 현재 요청된 페이지의 이전 웹 페이지 주소, 유입 경로 분석 가능. 요청에서 사용
		- User-Agent: 클라이언트의 애플리케이션 정보(웹브라우저 정보 등등..), 통계정보, 어떤 종류의 브라우저에서 장애가 발생하는지 파악할 수 있다. 요청에서 사용
		- Server: 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보, 응답에서 사용
		- Date: 메시지가 발생한 날짜와 시간, 응답에서 사용
	- 특별한 정보를 다루는 헤더
		- Host: 요청한 호스트 정보(도메인), 요청에서 사용하는 필수 헤더
			- 하나의 서버가 여러 도메인을 처리해야 할 때
			- 하나의 IP 주소에 여러 도메인이 적용되어 있을 때 구분
			- 가상 호스트를 통해 하나의 IP로 여러 도메인을 한번에 처리할 수 있는 서버에 요청을 보낼 때 실제로 서버내에서는 애플리케이션이 여러개 동작하고 있는데 어떻게 클라이언트가 보내는 요청을 어떤 서비스로 구별해서 처리해야될지 모르기 때문에 Host 헤더가 필요하다.
		- Location: 페이지 리다이렉션
			- 웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면 Location 위치로 리다이렉트한다. 
			- 201 Created 에서 Location 값은 요청에 의해 생성된 리소스 URI
			- 3xx Redirection : Location 값은 요청을 자동으로 리디렉션하기 위한 대상 리소스를 가리킨다.
		- Allow : 허용가능한 HTTP 메서드
			- 405 Method Not Allowed 에서 응답에 허용가능한 메소드를 포함해서 정보 제공. 
		- Retry-After: 유저 에이전트가 다음 요청을 하기까지 기다려야하는 시간
			- 503 Service Unavailable :서비스가 언제까지 작동불능인지 알려줄 수 있음.    
			- Retry-After: Mon, 1 WED 2000 22:22:11 GMT (날짜 표기로 알려줌)
			- Retry-After: 120 (초 단위로 표기) 
	- 인증
		- Authorization: 클라이언트의 인증 정보를 서버에 전달
		- WWW-Authenticate: 리소스 접근시 필요한 인증 방법 정의
			- 401 Unauthorized 응답과 함께 사용한다. 
	- 쿠키
		- Set-Cookie: 서버에서 클라이언트로 쿠키 전달(응답)
		- Cookie: 클라이언트가 서버에서 받아 저장한 쿠키를 HTTP 요청시 서버로 전달
			- 쿠키로 사용자 로그인 세션 관리, 광고 정보 트래킹
			- 쿠키 정보는 항상 서버에 전송되고
			- 네트워크 트래픽이 추가로 유발되기 때문에 최소한의 정보만 사용해야한다. 
			- domain
				- 도메인 명시하면 명시한 문서 기준도메인은 물론이고 서브도메인도 쿠키에 접근 가능
				- 도메인을 명시하지 않으면 현재 문서 기준 도메인에서만 접근 가능
			- Secure : 쿠키는 http, https 구분하지 않지만 secure 적용시 https인 경우만 전송
			- HttpOnly: XSS 공격 방지, 자바스크립트에서 접근안되고 HTTP 전송용으로만 사용
			- SameSite: XSRF 공격 방지, 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠키 전송 가능 
	- 캐시와 조건부 요청
		- 캐시: 데이터가 변경되지 않아도 반복해서 데이터를 네트워크를 통해 다운로드 받지 않기 위해 브라우저 캐시에 응답결과를 저장하고 유효시간 안이라면 캐시에서 조회하여 사용. 캐시 가능 시간동안 네트워크를 사용하지 않아 빠르다.  유효시간 초과시 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다. 
		- 응답시   cache-control: max-age=60
		- 캐시 유효기간이 지났다고 하더라도 서버에서 동일한 파일을 다시 다운로드 받아야 하는가?
			- 서버에서 기존 데이터가 변경되지 않은 경우 : 데이터를 전송하는 대신 저장해두었던 캐시를 재사용할 수 있는 방법은 없을까? (단 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요)
			-  캐시 유효시간이 초과해도 서버의 데이터가 갱신되지 않으면 서버는 304 Not Modified 및 헤더 메타 정보만 응답. 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타정보를 갱신하고 캐시에 저장되어있는 데이터 재활용한다. 
				- 응답시 서버에서 추가로 검증 헤더 설정 : Last-Modified (데이터가 마지막에 수정된 시간)
				- 캐시 유효기간이 지난 후 클라이언트 측에서 재요청시 if-modified-since: 20220710 05:00:00 로 데이터 최종 수정일 체크(조건부 요청)
				- 서버의 데이터 최종 수정일과 비교 체크 후 수정되지 않았다고 확인되면 서버는 304 Not Modified 로 응답한다.(HTTP BODY 없음) 
				- 클라이언트는 캐시를 다시 세팅하고 과거의 응답 결과를 재사용, cache-control 헤더 데이터 갱신하고 캐시에서 조회하여 사용. 
		- 검증 헤더: 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터, Last-Modified, ETag
		- 조건부 요청 헤더: 검증 헤더로 조건에 따른 분기
		- If-Modefied-Since: Last-Modefied 사용
			- 데이터 미변경: 캐시와 서버의 Last-Modified 값이 동일하면 304 Not Modified 응답.(헤더데이터만 전송)
			- 데이터 변경됨: 캐시와 서버의 Last-Modified 값이 다르므로 200 OK 응답, 모든 데이터를 새로  전송
			- 단점 : 
				- 1초 미만 단위로 캐시 조정이 불가능하다. 
				- 날짜 기반의 로직을 사용하므로 같은 데이터지만 수정 날짜가 다른 경우 변경되었다고 판단해서 재전송
				- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
					- 예: 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우
		- If-None-Match: ETag(Entity Tag) 사용 : 캐시용 데이터에 임의의 고유한 버전 이름을 달아두고 활용
			- 예) ETag: "v1.0" /  ETag: "asdfghjkl"(해쉬 알고리즘) 
			- 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성)
			- 그래서 ETag를 보내서 같으면 유지, 다르면 재전송하는 방식으로 활용가능
			- 즉, 캐시 제어 로직을 서버에서 완전하게 관리할 수 있다.
			- 클라이언트는 단순히 ETag 값을 서버에 제공하면되고 그 값이 어떤의미인지, 캐시 매커니즘을 몰라도 된다. 
			- 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신 
		- 조건이 만족하면 200 OK
		- 조건이 만족하지 않은 경우 304 Not Modified
	- 캐시 제어 헤더
		- Cache-Control: 캐시 제어
			- max-age : 캐시 유효시간, 초단위임
			- no-cache : 데이터는 캐시해도 되지만, 항상 Origin 서버에 검증하고 사용해야함. 캐시서버, 프록시 서버가 아니라 오리진 서버로부터 검증받아야함.
			- no-store : 데이터에 민감한 정보가 있으므로 저장하면 안되므로 메모리에서 사용하고 바로 삭제
		- Pragma: 캐시 제어(하위 호환) 
			- no-cache , HTTP 1.0 하위 호환
		- Expires: 캐시 유효기간(하위 호환)
			- 캐시 만료일을 정확한 날짜로 지정
			- HTTP 1.0부터 사용
			- 지금은 더 유연한 Cache-Control : max-age를 사용하는게 좋다. 
			- Cache-Control: max-age와 함께 사용되면 Expires는 무시됨.
		- 검증 헤더 : ETag, Last-Modified
		- 조건부 요청 헤더 
		- If-Match, If-None-Match : ETag 값 사용
		- If-Modified-Since, If-Unmodified-Since: Last-Modified 값 사용
	- 프록시 캐시
		- public 캐시 / private 캐시
		- Cache-Control: public - 응답이 public 캐시에 저장되어도 된다.
		- Cache-Control: private -응답이 해당 사용자만을 위한 것이므로 private 캐시에 저장되어야한다. 기본값.
		- Cache-Control: s-maxage - 프록시 캐시에만 적용되는 max-age
		- Age: 60 (HTTP 헤더) : 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)