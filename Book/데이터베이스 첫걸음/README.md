# 데이터베이스 첫걸음

- 공유 자원 접근 문제(동시성 제어)

- 데이터를 어떤 포맷으로 관리할 것인가? 조회,추가,수정,삭제에 효율적인 타입으로 =>성능과도 연결  

- 데이터베이스를 다룰 때 고려할 문제들

1. 초기 비용과 운영 비용을 면밀히 고려해보고 도입해야한다.  
2. 추후 마이그레이션이 필요한지... 필요할 것 같다면 그 부분도 생각해보기.
3. 성능 최적화 => 비용 절감 효과, 사용자에게 만족스러운 경험 제공

명확한 의도를 가지고 설계된 아키텍처! - 요구사항, 가용성, 확장성, 신뢰성, 재해 대책, 성능, 보안, 비용을 고려하여 결정.   

### 안정성을 추구하기 위한 다중화 (가용성)

- 컴포넌트를 병렬화하는 클러스터링(Clustering): 예비 DB로 장애에 대비, 단일장애점 파악, Active-Active, Active-Standby

- 확장성(Scalability) 확보 

- 리플리케이션(Replication) : 데이터 동기화를 통해 DB서버와 저장소를 다중화 => 재해 분산 및 부하 분산

### 성능을 추구하기 위한 다중화

- 복수의 서버가 1개의 저장소를 공유하도록 구성되어있다면 병목이 발생할 수 있음. (Shared Disk)
- Shared Nothing 아키텍처(샤딩 Sharding) : 네트워크 이외의 자원을 모두 분리하여 아무것도 공유하지 않는 방식. DB다운에 대비하여  Covering 구성을 고려해야함. 

## DMBS의 계층
인스턴스 : DBMS 동작단위로, OS입장에서는 프로세스
데이터베이스
스키마 : 폴더에 해당. 
오브젝트 : 테이블, 인덱스 , 스토어드 프로시저 등...

MySQL : 3계층 ( 인스턴스- 스키마 - 오브젝트) 
Oracle : 4계층 (인스턴스 - 데이터베이스1개 - 스키마 - 오브젝트) 
PostgreSQL : 4계층 ( 인스턴스 - 데이터베이스 - 스키마 - 오브젝트) 

## DBMS의 트랜잭션과 동시성 제어

### 트랜잭션의 4가지 특성
1. Atomicity(원자성) : 데이터 변경을 수반하는 일련의 데이터 조작이 전부 성공할 지 실패할 지를 보증하는 구조. 모두 성공하면 COMMIT, 처리 중 오류 발생시 ROLLBACK 실행.

2. Consistency(일관성): 데이터베이스 오브젝트에 대해 각종 정합성 제약을 추가하여 일관성을 유지. 예를 들어 사용자를 식별하기 위한 임의의 일련번호를 발급할때 일련번호에 유니크 제약을 설정하면 중복된 사용자 번호를 지정할 수 없다. 

3. Isolation(고립, 격리성): 복수의 사용자가 일련의 데이터 조작을 동시에 실행해도 각각의 처리가 모순 없이 실행되는 것을 보증한다. 즉 복수의 트랜잭션이 순서대로 실행되는 것과 같은 결과를 얻는다. 병렬 실행이 일관성있게 수행되는 것이다. DB에서는 테이블 전체 혹은 행 단위로 후속처리에 대해 락을 걸어서 블록시키는 방법이 있다. 

격리 수준(Transaction Isolation Level) : 4번의 Serializable이 가장 엄격한 수준의 격리수준이다. 격리 수준이 완화되면서 Phantom Read, Fuzzy Read, Dirty Read와 같은 현상이 발생한다. 

	4. Serializable : 안전하지만 성능면에서는 실용적이지 않을 수 있다. 
	3. Repeatable Read - Phantom Read 현상 발생 : 어떤 트랜잭션을 읽을 때 선택할 수 있는 데이터가 나타나거나 사라지는  현상(다른 사용자가 INSERT, DELETE하여 조회를 반복할시 결과가 달라짐)
	2. Read Committed - 추가로 Fuzzy Read 현상 발생 : 어떤 트랜잭션이 이전에 읽어 들인 데이터를 다시 읽어 들일 때 2회 이후의 결과가 1회 때와 다른 현상.  
	1. Read Uncommitted - 추가로 Dirty Read 현상 발생: 어떤 트랜잭션이 커밋되기도 전에 다른 트랜잭션에서 데이터를 읽는 현상.

4. Durability(지속성) : 트랜잭션 조작을 COMMIT하고 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이 되어 그 결과를 잃지않는다.  시스템이 비정상일 때도 충족해야함. 트랜잭션 조작을 하드 디스크에 로그로 기록하고 시스템에 이상이 발생하면 그 로그를 사용해 이상 발생 전의 상태까지 복원하는 것으로 지속성을 실현하고 있음. 

## 인덱스 : 어떻게 데이터를 빠르게 찾을 수 있을까? 

인덱스는 테이블의 컬럼 단위로 생성되며, 하나의 열에는 하나의 인덱스를 설정하는게 일반적이다.

- Clustered Index(클러스터형 인덱스) : 기본키로 지정하면 자동 생성되며 테이블에 1개만 생성 가능하다. (Primary Key) 
- Secondary Index(보조 인덱스) : 고유 키로 지정하면 자동 생성되며 여러개를 만들 수 있지만 자동 정렬 되지는 않는다. 

### 인덱스의 장점

- 적절한 인덱스를 설정하면 데이터 검색 속도가 매우 빨라진다.
- 전체 시스템 성능 향상

### 인덱스의 단점

- 인덱스는 추가 공간 필요. (테이블 크기의 10% 정도의 공간 추가로 필요)
- 인덱스를 처음 만들 때 시간 소요
- 데이터의 변경 작업이 자주 일어나거나 인덱스를 잘못 사용하면 오히려 성능이 나빠질 수 있다.  

### 인덱스 작동 원리

- 인덱스는 모두 균형 트리(B-tree)로 만들어진다. 인덱스가 없으면 Full Table Scan을 해야하지만, 인덱스가 있으면 루트 노드(root) 부터 검색해서 최적의 리프 노드(leaf)로 바로 이동해서 검색한다. 삽입시 노드에 더이상 저장공간이 없으면 노드를 분할하는 작업이 발생하므로 분할 작업이 너무 자주 일어나면 성능에 안 좋다.  

		균형 트리란? 균형 트리 구조에서 데이터가 저장되는 공간은 노드이며 MySQL에서는 page라고 부른다. 최소저장단위는 16KB

### 인덱스의 구조

- 클러스터형 인덱스: 행 데이터를 지정한 열로 정렬한 후, 각 페이지의 인덱스로 지정된 열의 첫번째 값을 가지고 루트 페이지를 만든다. 데이터 페이지도 인덱스에 포함되어 구성된다.

- 보조 인덱스 : 데이터 페이지와는 별개의 공간에 인덱스 페이지를 생성한다. 데이터 페이지와 인덱스 페이지는 별개로 존재한다. 페이지 번호와 위치를 조합하여 기록한다. 

### 인덱스를 효과적으로 사용하기

- 인덱스를 사용하려면 SQL문안에 인덱스가 생성된 열 이름이 Where 절에 포함되어야 한다. 
	- MySQL이 인덱스를 사용하는게 효율적인지 전체 검색을 하는게 효과적인지 판단후 인덱스 검색이 효율적이라면 인덱스로 검색함. 
	- 단 WHERE절에서 열에 연산이 필요하다면 인덱스를 사용하지 않음. 실제로 실행 계획(Execution Plan)을 통해 확인 가능하다. 
- WHERE절에서 사용되더라도 자주 사용해야 가치가 있다. INSERT 작업이 많고 조회를 가끔 한다면 비효율적이다. 
- 데이터의 중복이 높은 열은 인덱스를 만들어도 별 효과가 없다. 
- 클러스터형 인덱스(기본키)는 조회할때 가장 많이 사용되는 열에 지정하는 것이 효과적이다.

## 정규형

함수 종속성: 기본키와 다른 열 사이에 성립하는 함수적인 유일성.

- 제1 정규형 : 테이블 셀에 복합적인 값을 포함하지 않는다. 기본키를 특정하면 어떤 레코드의 열 값 전체가 고유하게 특정된다. 
- 제2 정규형 : 전체 열은 기본 키만으로 함수 종속을 가져야하며, 기본 키를 구성하는 열의 일부에만 함수 종속이 존재하지 않아야 한다. 
- 제3 정규형 : 추이함수 종속을 제거하라. (기본키 이외의 키 간에 발생하는 함수 종속)

## 성능 

- 응답시간과 처리율
- 처리율은 시스템의 자원 용량을 결정하는 요인이므로 매우 중요. 
- 보통 동시 실행 처리 수가 증가할수록 시스템 자원이 많이 필요하다. 자원이 한계에 이르면 병목 현상이 발생 
- 처리율과 응답시간이 극단적으로 나빠지기 시작하는 처리량을 한계점이라고 부른다. 
- 인덱스는 적절히 사용한다면 테이블 데이터에 영향을 주지 않고, SQL문을 변경하지 않아도 성능을 개선할 수 있는 방법이다. 

### 데이터베이스 결과 응답 순서

- 1. 구문 오류를 체크하는 파스(Parse)
- 2. 옵티마이저가 데이터베이스의 통계정보를 참조해서 실행 계획을 작성(풀 스캔 또는 인덱스 이용) -> 실행 계획 판단하여 결정
- 3. 데이터 접근, 처리 -> 반환   
