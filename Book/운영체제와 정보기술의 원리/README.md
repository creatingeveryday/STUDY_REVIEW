# 컴퓨터 네트워킹 하향식 접근

## 1. 인터넷과 프로토콜

-   인터넷이란?
    -   정의: 네트워크의 연결
    -   구성요소
        -   하드웨어
            -   host(end system): 클라이언트와 서버로 구분할 수 있다.
            -   links  
                -   구리선, 동축 케이블, 광케이블, 라디오 스펙트럼, 위성 전파
                -   전송률(링크 대역폭) (transmission rate, link capacity, bandwith) - 단위 bit per second (bps)
                -   end system 과 router 간 링크를 통해 데이터를 교환한다.
            -   router, switch
                -   라우터와 스위치는 도착하는 패킷을 받아서 출력 통신 링크로 패킷을 전달한다.
        -   소프트웨어
            -   운영체제
            -   응용 프로그램
            -   프로토콜
                -   프로토콜은 둘 이상의 통신 개체 간에 교환되는 메시지 포맷과 순서뿐만 아니라, 메시지의 송수신과 다른 이벤트에 따른 행동을 정의한다.
                -   TCP/IP 는 인터넷에서 가장 중요한 프로토콜이다.
-   네트워크 엣지
    -   접속 네트워크(access network): end system 간에 연결되는 경로상의 첫번째 라우터에 연결하는 네트워크
        -   DSL, 케이블, FTTH, 5G-FW
        -   이더넷(Ethernet) 스위치
        -   무선 LAN(Wi-Fi) - AP(access point)
        -   3G / 4G LTE / 5G
    -   비트의 전달 방식
        -   출발지 host(end system)이 비트를 전송한다.
        -   첫번째 라우터가 비트를 수신한 후에 경로 상의 다음 라우터로 전송하고 두번째 라우터가 비트를 수신한다.
        -   비트는 물리 매체(꼬임쌍선, 동축케이블, 광케이블, 지상파, 위성파) 상에서 전자파나 광 펄스를 전파하여 전송한다.
-   네트워크 코어
    -   네트워크 코어는 인터넷의 end system 을 연결하는 패킷 스위치(라우터)와 링크의 그물망 형태를 가지고 있다.
    -   패킷 교환
        -   host(end system) 간의 통신시 긴 메시지를 패킷(paket)이라는 작은 데이터 단위로 분할하여 전송된다.
        -   각 패킷은 패킷 스위치(라우터)와 링크계층 스위치를 거치게된다.
        -   라우터는 저장 후 전달 전송 방식을 이용한다. 패킷을 전달시 전체 패킷을 수신할 때까지 버퍼에 패킷의 비트를 저장한 후 전체 패킷의 비트를 수신하면 완성된 패킷을 다음 라우터로 전송한다.
    -   큐잉 지연과 패킷 손실
        -   라우터는 링크에 대해 출력 버퍼를 가지고 있으며 그 링크로 송신하려는 패킷을 저장하고 있다.
        -   도착하는 패킷이 전송되어야 하는 링크가 다른 패킷을 전송하고 있다면 도착하는 패킷이 출력 버퍼에서 대기해야하는 큐잉 지연(Queuing delay) 현상이 발생한다.
        -   버퍼 공간의 크기가 유한하므로 버퍼 공간이 꽉 차있다면 패킷 손실이 발생할 수도 있다.
    -   포워딩 테이블과 라우팅 프로토콜
        -   라우터는 패킷을 어느 링크로 전달할 지 어떻게 결정하는가?
            -   모든 host(end system)은 고유의 IP 주소를 가진다.
            -   패킷을 전송할 때 패킷의 헤더에 목적지의 IP 주소를 포함하여 전송한다.
            -   각 라우터는 목적지 주소를 라우터의 출력 링크로 매핑하는 포워딩 테이블을 갖고 있다.
            -   라우터는 도착한 패킷을 조사하여 IP 주소를 확인 후 IP 주소를 이용하여 포워딩 테이블을 검색한다.
            -   확인된 출력 링크로 도착한 패킷을 전송한다.
        -   포워딩 테이블은 어떻게 설정되는가?
            -   인터넷은 자동으로 포워딩 테이블을 설정하는 데 이용되는 라우팅 프로토콜을 가지고 있다.
    -   데이터 전달 방식
        -   회선 교환 방식(circuit switching)
        -   패킷 교환 방식(packet switching)

- 프로토콜 계층
    -   프로토콜은 계층 구조를 이루고 있다.
    -   각 계층은 인접 계층과 연계하여 특정한 서비스를 구현한다.
    -   각 계층에서 패킷은 헤더 필드와 페이로드 필드라는 두 가지 형태의 필드를 가지고 있으며 페이로드는 일반적으로 상위 계층의 패킷을 의미한다.
    -   상위 계층에서 하위 계층으로 메시지 이동시 캡슐화 과정을 거친다.
 
 - 애플리케이션 계층

	-   네트워크 애플리케이션, 애플리케이션 계층 프로토콜(HTTP, SMTP, FTP 등)이 존재하는 계층
	-   애플리케이션 계층 프로토콜을 통해 다른 end system의 애플리케이션과 정보 패킷(message)을 교환할 수 있다.

- 트랜스포트 계층

	-   클라이언트와 서버 간에 애플리케이션 계층 메시지를 전송하는 서비스를 제공한다.
	-   트랜스포트 계층 패킷을 segment라고 부른다.
	-   TCP
	    -   연결 지향형 서비스 제공
	    -   연결 지향형 서비스는 애플리케이션 계층 메시지 전달을 보장하고 흐름 제어 기능을 포함한다.
	    -   긴 메시지를 짧은 메시지로 나누고 혼잡 제어 기능을 제공하여 네트워크가 혼잡할 때 출발지의 전송률을 조정한다.
	-   UDP
	    -   비연결형 서비스 제공
	    -   비연결형 서비스는 전달보장, 흐름제어, 혼잡 제어 기능 없이 단순히 애플리케이션 계층의 메시지를 전송만 하는 간단한 서비스다.

- 네트워크 계층(IP 계층)

	-   네트워크 계층 패킷을 datagram이라고 부른다.
	-   네트워크 계층은 호스트 간 datagram을 라우팅 하는 책임 갖고 있다.
	    -   출발지 end system(호스트)에서 트랜스포트 계층 프로토콜은 트랜스 포트 계층 세그먼트와 목적지 주소를 네트워크 계층으로 전달한다.
	    -   네트워크 계층은 이렇게 전달받은 목적지 주소를 이용하여 목적지 end system 의 트랜스포트 계층으로 세그먼트를 운반한다.
	-   네트워크 계층 프로토콜은 IP 프로토콜과 라우팅 프로토콜을 포함한다.
	-   IP
	    -   네트워크 계층을 가진 모든 인터넷 요소는 IP 프로토콜을 수행해야한다.
	-   라우팅 프로토콜
	    -   출발지와 목적지 사이에서 데이터그램이 이동하는 경로를 결정한다.

- 링크 계층

	-   경로 상의 한 노드에서 다른 노드로 패킷을 이동하기 위해 네트워크 계층은 링크 계층 서비스에 의존하고 있다.
	-   각 노드에서 네트워크 계층은 데이터그램을 아래 링크 계층으로 보내고 링크 계층은 전달 받은 데이터그램을 경로상의 다음 노드에 전달한다. 다음 노드에서 링크 계층은 데이터그램을 상위 네트워크 계층으로 보낸다.
	-   링크 계층 패킷은 프레임(frame)이라고 부른다.

- 물리 계층
	-   링크 계층의 패킷(frame) 내부의 각 비트를 이동하는 책임을 수행한다.


## 2. 애플리케이션 계층

#### 네트워크 애플리케이션의 원리
	서로 다른 위치의 end system 에서 동작하고 네트워크를 통해 서로 통신하는 프로그램을 네트워크 애플리케이션이라고 한다.
	end system에만 애플리케이션 소프트웨어가 존재한다.
	네트워크 코어 장비에서 실행되는 소프트웨어까지 작성할 필요가 없고 작성할 수도 없다. 
	각 계층은 각기 맡은 책임만을 수행한다. 계층별로 나누어 관리하고 발전하고 개발할 수 있다.
- 네트워크 애플리케이션의 구조
	- 클라이언트 - 서버
	- P2P(peer to peer)
- 프로세스간 통신
	- 개요
		- 실제로 통신하는 것은 프로그램이 아니라 프로세스다.
		- 프로세스는 컴퓨터 네트워크를 통한 메시지 교환 (요청-응답)을 통해 서로 통신한다.
		- 프로세스 간의 통신을 위한 규칙은 end system의 운영체제에 의존한다.
	- 클라이언트와 서버 프로세스
		- 클라이언트 프로세스
			- 프로세스 간의 통신 세션에서 다른 프로세스와 세션을 시작하려고 접속을 초기화(통신초기화)하는 프로세스를 의미한다.
		- 서버 프로세스
			- 세션을 시작하기 위해 접속을 기다리는 프로세스를 의미한다.
	- 프로세스와 컴퓨터 네트워크 사이의 인터페이스
		- 프로세스는 소켓(socket)을 통해 네트워크로 메시지를 보내고 받는다.
		- 소켓은 애플리케이션 계층과 트랜스포트 계층간의 인터페이스다.
		- 소켓은 애플리케이션과 네트워크 사이의 API 라고도 한다.
		- 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖고 활용할 수 있지만 소켓의 트랜스포트 계층은 거의 통제할 수 없다. 트랜스포트 프로토콜의 선택과 최대 버퍼와 최대 세그먼트 크기 같은 매개변수 설정 밖에 할 수 없다.
	- 통신 대상 프로세스는 IP 주소와 포트번호로 식별할 수 있다.
	- 트랜스포트 계층 포로토콜은 수신 프로세스의 소켓으로 네트워크를 통해 메시지를 이동시킬 책임이 있다.
	- 트랜스포트 계층 프로토콜이 제공하는 서비스
		- 신뢰적 데이터 전송(reliable data transfer)
			- 트랜스포트 계층 프로토콜은 신뢰적 데이터 전송 서비스를 제공할 수 있다. 
			- 패킷이 손실되면 host 혹은 router에 의해 패킷이 버려질 수 있다.
			- 패킷이 손실되면 큰일나는 애플리케이션이 존재한다. 이 경우 데이터가 오류 없이 수신 프로세스에 도착할 것이라는 확신을 제공하는 기능이 필요하다. 은행 같은 경우 이러한 기능은 무조건 필요하다.
			- 신뢰적 데이터 전송 서비스는 프로토콜이 데이터 전송을 안전하게 보장하는 기능이다.
			- 반면 이러한 서비스가 필요하지 않은 애플리케이션은 약간의 데이터 손실을 감수할 수 있다.
				- 오디오나 비디오의 품질 저하
		- 처리율
			- 트랜스포트 계층 프로토콜은 처리율 보장을 제공할 수 있다. 
			- 처리율은 네트워크 경로를 따라 두 프로세스간의 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율을 의미한다. 
			- 애플리케이션이 최소로 필요로 하는 처리율을 트랜스포트 프로토콜이 보장할 수 있어야하는 경우가 있다. 처리율 요구사항을 갖는 애플리케이션을 대역폭 민감 애플리케이션이라고 한다. 
				- 예) 인터넷전화
			- 반면 이러한 최소한의 처리율을 보장할 필요가 없는 애플리케이션을 탄력적 애플리케이션(elastic application) 이라고 한다. 
				- 예) 메일, 파일 전송
		- 시간
			- 트랜스포트 계층 프로토콜은 시간 보장을 제공할 수 있다. 
			- 송신자가 소켓으로 내보내는 모든 비트가 수신자의 소켓에 특정 시간내에 도착해야만 하는 애플리케이션
				- 예) 인터넷 전화, 가상환경, 원격 화상 회의, 등 실시간 상호작용 애플리케이션
		- 보안
			- 트랜스포트 계층 프로토콜은 애플리케이션에 하나 이상의 보안 서비스를 제공할 수 있다.
				- 트랜스포트 프로토콜은 송신 호스트의 송신 프로세스가 전송하는 모든 데이터를 암호화할 수 있고 수신 호스트에서 그 데이터를 수신프로세스로 전달하기 전에 데이터의 암호를 해독할 수 있다.
			- 데이터 무결성 서비스를 제공한다. 
			- 종단 인증 서비스를 제공한다. 
- 인터넷 전송 프로토콜이 제공하는 서비스 비교
    -   TCP 와 UDP는 애플리케이션에 서로 다른 서비스를 제공한다.
    -   애플리케이션의 요구사항을 살펴보고 결정해야한다.
        -   데이터 손실
        -   대역폭
        -   시간 민감성
    -   TCP
        -   연결지향형 서비스
            -   애플리케이션 계층 메시지를 전송하기전 클라이언트와 서버가 서로 전송 제어 정보를 교환한다(핸드쉐이킹)
            -   이렇게 TCP 연결이 두 프로세스의 소켓사이에 존재하게 되고 그때부터 서로 통신을 시작한다.
            -   수신 프로세스가 받을 수 있는 용량의 데이터만 보낼 수 있다.
        -   신뢰적인 데이터 전송 서비스
            -   TCP는 패킷 손실 없이 수신 소켓으로 데이터를 전송할 수 있게 보장한다.
            -   모든 데이터를 오류 없이 올바른 순서로 전달한다.
            -   에러가 발생할 경우 재전송을 요청한 후 에러가 없는 데이터가 모두 도착했을 때 애플리케이션 레이어에 전달한다.
            -   HTTP, SMTP, FTP는 데이터 손실이 발생하면 안되기 때문에 TCP를 사용한다.
        -   혼잡 제어 서비스
            -   네트워크가 혼잡 상태에 이르면 프로세스 속도를 낮추어서 각 TCP 연결이 네트워크 대역폭을 공평하게 공유할 수 있게끔 한다.
    -   UDP
        -   비신뢰적인 서비스
            -   비연결형이므로 두 프로세스가 통신을 하기전에 핸드셰이킹 하지 않는다.
            -   그래서 전반적으로 TCP보다 속도가 빠르다.
            -   순서가 뒤바뀔수도 있고 데이터 손실이 발생할 수도 있다.
        -   송신 측은 데이터를 원하는 속도로 보낼 수 있지만 실제로 제한된 대역폭, 혼잡으로 인해 전송 속도가 감소할 수 있다.
-   WEB과 HTTP
    -   URL
        -   웹 페이지의 객체는 URL로 지정할 수있는 하나의 파일이다.
    -   HTTP(HyperText Transfer Protocol)
        -   HTTP는 메시지의 구조 및 클라이언트와 서버가 메시지를 어떻게 교환하는지에 대해 정의한다.
        -   데이터 손실이 일어나면 안되기 때문에 TCP를 전송 프로토콜로 사용한다.
        -   비상태 프로토콜(stateless)
            -   서버가 클라이언트에게 요청파일을 보낼때 서버는 클라이언트에 관한 어떠한 상태정보도 저장하지 않는다.
        -   기본적으로 지속 연결 모드로 사용하지만 비지속 연결 모드를 사용할 수 도 있음.
            -   지속 연결: 모든 요청과 응답이 같은 TCP 연결을 통해 이루어 진다.(persistent)
            -   비지속 연결: 각 요청와 응답이 분리된 TCP 연결을 통해 이루어진다.(non-persistent)
        -   HTTP 메시지 구조
            -   ASCII 텍스트로 쓰여있음.
            -   요청 메시지
                -   request line
                    -   method 필드: GET, POST, PUT, DELETE, HEAD...
                    -   url 필드
                    -   HTTP 버전 필드
                -   header line
                    -   헤더 필드 이름: 값 + CR + LF
                -   entity body
            -   응답 메시지
                -   status line
                    -   HTTP 버전 필드
                    -   상태 코드 필드
                    -   해당 상태 코드 메시지 필드
                -   header line
                    -   헤더 필드 이름: 값 + CR + LF
                -   entity body
        -   HTTP 개발 역사
            -   HTTP/1
                -   1996년
                -   비지속 연결
            -   HTTP/1.1
                -   1999년
                -   동기적 지속 연결
            -   HTTP/2.0
                -   2015년
                -   비동기적 지속 연결
    -   쿠키
        -   무상태 프로토콜인 HTTP를 사용하지만 사용자의 접속을 제어하거나 사용자에 따라 다른 콘텐츠를 제공해야할 필요성 때문에 개발되었다.
        -   서버에는 사용자의 state 를 쿠키로 저장한다.
    -   웹 캐시
        -   수 많은 사람들이 같은 사이트에 접속하는 경우 오버헤드가 커진다. 즉 부하가 생기고 속도가 느려진다.
        -   똑같은 중복 요청의 경우 origin 서버까지 요청이 가지 않아도 동일한 결과를 응답할 수 있다. origin 서버로부터 이전에 미리 받아서 저장하고 있던 데이터로 중간의 프록시 서버가 응답한다.
        -   CDN 회사는 웹 캐시를 설치하여 많은 트래픽을 분산하고 있다.
        -   그렇다면 복사본이 최신 버전이라는 것을 어떻게 보장할 것인가?
            -   HTTP 는 클라이언트가 브라우저로 전달되는 모든 객체가 최신의 것임을 확인하면서 캐싱을 하게 해주는 방식을 갖고 있다. 이 방식을 조건부 GET 이라고 한다.
            -   GET 방식과 if-modified-since 헤더를 사용한다.
-   SSL / TLS
    -   TCP 데이터 전송시 암호화를 제공하는 프로토콜
    -   Secured Socket Layer / Transpost Layer Security
    -   애플리케이션 계층 프로토콜
    -   서버와 통신 시작 시 TCP의 핸드셰이킹처럼 SSL 연결을 먼저 확립하고 암호화된 방식으로 통신할 수 있게 한다.
    -   http => +SSL/TLS => https
-   인터넷 전자메일
    -   구성요소
        -   user agent
            -   사용자가 메시지를 읽고 응답하고 전달하고 저장하고 구성하게 해준다.
            -   예) gmail, apple mail, naver mail...
        -   mail server
            -   메일 서버 내에는 mail box가 존재한다.
            -   mail box는 메일을 유지하고 관리한다.
        -   SMTP(Simple Mail Transfer Protocol)
            -   인터넷 전자 메일을 위한 애플리케이션 계층 프로토콜
            -   TCP 이용
-   DNS
    -   IP 버전 4 주소의 경우 32 bit 길이의 주소를 가지는데 사람이 읽고 기억하기가 어렵다.
    -   사용자가 www.google.com 이라고 주소를 입력하면 해당하는 IP 주소를 알려주는게 DNS 시스템이다.
    -   데이터센터에서 여러 대의 서버를 두는 경우 호스트 이름은 동일하더라도 IP 주소를 다르게 관리할 수 있어 트래픽을 분산할 수 있는 장점도 있다.
    -   DNS 시스템은 지역적으로도 분산되어 있고 계층적으로 역할이 나누어져있다.
    -   Root - Top Level - authoritative



## 3. 트랜스포트 계층

-   트랜스포트 계층이 제공하는 서비스
    -   트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 애플리케이션의 프로세스 간의 논리적인 통신을 제공한다.
        -   현재 실행되고 있는 다수의 프로세스를 구별하여 통신할 수 있다.  
            
        -   end system 사이의 IP 전달 서비스를 end system 에서 동작하는 두 프로세스 간의 전달 서비스로 확장한다.
            -   트랜스포트 계층은 세그먼트를 검사하여 올바른 목적지의 프로세스의 소켓에게 전달한다. 호스트의 각 소켓은 포트번호도 할당받는다.  
                
            -   호스트 사이의 전달을 프로세스 사이의 전달로 확장하는 것을 트랜스포트 계층 다중화(Transport-layer multiplexing) 또는 역다중화(demultiplexing)라고 부른다.  
                -   트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 역다중화라고 한다.
                -   출발지 호스트에서 소켓으로부터 데이터를 모으고 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화하고 그 세그먼트들을 네트워크 계층으로 전달하는 작업을 다중화라고 한다.
            -   소켓은 유일한 식별자를 가지고 있으며, 각 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 특별한 필드를 갖고 있다. 그 필드는 출발지 포트 번호 필드와 목적지 포트 번호 필드이다. 각각의 포트 번호는 0~ 65535까지의 16비트 정수다.  
                
        -   TCP와 UDP는 헤더에 오류 검출 필드를 추가함으로써 무결성 검사를 수행할 수 있다.
    -   통신 방법
        -   송신: 송신 측의 트랜스포트 계층은 송신 애플리케이션 프로세스로부터 수신한 메시지를 세그먼트(segment)로 변환하고 트랜스포트 계층 헤더를 추가한다. 그 후 네트워크 계층으로 세그먼트를 전달한다. 네트워크 계층은 호스트 사이의 논리적 통신을 제공한다고 할 수 있다.
        -   수신: 수신 측의 트랜스포트 계층은 네트워크 계층으로부터 전달받은 세그먼트를 데이터로 이용할 수 있게 만든다.
    -   네트워크 계층의 IP 프로토콜이 패킷을 분실하거나 손상시켜도 애플리케이션에게 신뢰적인 데이터 전송 서비스를 제공할 수 있다. 또 네트워크 계층이 트랜스포트 계층 세그먼트의 기밀성을 보장할 수 없을 때도 메시지를 암호화 할 수 있다.  
        
-   UDP(User Datagram Protocol)
    -   비신뢰적이고 비연결형인 서비스 제공
        -   각각의 세그먼트는 독립적으로 취급이 된다.
        -   TCP에 비해 상대적으로 속도가 빠르다.
        -   다중화와 역다중화 기능과 간단한 오류 검사 기능만을 제공한다.
        -   UDP를 사용하려면서 신뢰적인 데이터를 전송하려면 애플리케이션 자체에서 확인응답 기능과 재전송 기능을 제공해야한다. 이런 방식의 장점은 TCP의 혼잡 제어 메커니즘에 의해 전송률 억제를 강요당하지 않고도 신뢰적으로 통신할 수 있다.
    -   UDP 다중화와 역다중화
        -   UDP 소켓은 목적지 IP 주소와 목적지 포트 번호로 구성된 두 요소의 집합으로 구별된다.  
            
    -   UDP 세그먼트 구조
        -   UDP 헤더는 2바이트씩으로 구성된 4개의 필드를 가진다. (4byte, 32bit)  
            -   출발지 포트 번호, 목적지 포트번호, 길이, 체크섬
            -   체크섬은 세그먼트에 오류가 발생했는지를 검사하기위해 수신 호스트가 사용한다.  
                
-   TCP
    -   신뢰적이고 연결지향형 서비스 제공
    -   신뢰적인 데이터 전송: 데이터가 순서대로 정확하게 전달되도록 보장
        -   흐름제어
        -   순서번호
        -   확인응답
        -   타이머
    -   혼잡 제어
    -   TCP 다중화와 역다중화
        -   TCP 소켓은 출발지 IP주소, 출발지 포트번호, 목적지 IP주소, 목적지 포트번호로 구성된 4가지 요소의 집합으로 구별된다.
        -   서버는 각기 다른 클라이언트가 보낸 세그먼트를 출발지 IP주소와 출발지 포트 번호로 구별한다.


## 4. 네트워크 계층


  - 네트워크 계층의 책임
    -   네트워크 계층은 호스트 사이의 통신 서비스를 제공한다.
    -   호스트는 IP 주소로 구별할 수 있다.
    -   IP 프로토콜은 트랜스포트 계층의 segment를 전달받아 IP 헤더를 붙여서 datagram(IP 계층의 패킷을 지칭)을 만들고 데이터 링크 계층으로 전달한다.
    -   라우팅
        -   출발지부터 목적지까지의 길을 설정해주는 것
        -   라우팅 알고리즘은 라우터의 포워딩 테이블을 생성하는 정보를 제공한다.
    -   포워딩
        -   결정되어있는 라우터를 따라서 패킷을 옮겨주는 것
        -   경로 이동시 라우터의 포워딩 테이블이 안내한다.
        - 목적지 기반 포워딩
        - 일반화된 포워딩

-   라우터
    -   구조
        -   입력포트
            -   input queue(버퍼)
            -   HOL blocking 현상
        -   출력포트
            -   대기 큐
        -   스위칭
	        - 입력 포트와 출력 포트를 연결한다.
        -   라우팅 프로세서
	        - 라우팅 프로세서는 control plane 영역 기능을 수행. 
	        - 기존의 라우터에서는 라우팅 프로토콜을 실행하고 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하며 라우터의 포워딩 테이블을 계산한다.
	        - SDN 라우터에서 라우팅 프로세서는 원격 컨트롤러와 통신하여 원격 컨트롤러에서 계산된 포워딩 테이블 엔트리를 수신하고 라우터의 입력포트에 이러한 엔트리를 설치한다. 
	        - 네트워크 관리 기능 수행

-   인터넷 프로토콜 (IP)
    -   IPv4, IPv6
    -   IP 헤더
        -   TTL(Time To Live)
	        - 데이터그램이 목적지에 도착하지 못했을 경우 네트워크 내에서 떠돌아다니는 것을 방지하기 위하여 설정이다. 목적지 까지 거쳐갈 수 있는 최대 라우터 개수를 의미한다.
        -   checksum
        -   출발지와 목적지 IP 주소
    -   주소 체계
	    - IPv4
		    - 32bit 길이의 식별자를 할당
		    - 사람이 보기 쉽게 8bit 단위로 나누고 십진수로 바꾸고 점을 찍어서 표현 예) 221.1.1.1
		    - 주소는 네트워크 ID 와 호스트 ID로 나뉜다.
			    - class A: 앞 8bit 가 네트워크 ID(0~127)로 사용, 뒤 24 bit 가 호스트 ID로 사용된다. 
			    - class B: 앞 16bit 가 네트워크 ID, 뒤 16 bit 가 호스트 ID
			    - class C: 앞 24bit 가 네트워크 ID, 뒤 8 bit가 호스트 ID
		    - 서브네트워킹
			    - 내트워크 내부의 임의의 논리적인 네트워크를 만들어 네트워크를 효율적으로 관리할 수 있다. 
		    - CIDR(Classless Inter-Domain Routing)
			    - 기존의 클래스 주소체계와 달리 보다 효율적이고 유연하게 네트워크 주소를 조직할 수 있다.
			    - 낮은 레벨의 네트워크를 모아서 하나의 네트워크처럼 활용할 수 있다.
	  
	    - DHCP 동적 호스트 구성 프로토콜
		    - DHCP는 호스트가 자신의 IP 주소를 네트워크에 있는 서버로부터 자동으로 얻을 수 있게 한다. 
		    - 접속하는 순간 DHCP 서버가 IP 주소 부여
		    - DHCP는 호스트 IP 주소의 할당 뿐만 아니라 서브넷 마스크, 디폴트 게이트웨이 주소나 로컬 DNS 서버 주소 같은 추가 정보도 얻게 해준다.
		    - DHCP는 호스트가 빈번하게 접속하고 떠나는 영역에서 폭 넓게 사용된다. 
		    - 떠난 호스트의 주소를 회수하여 다른 호스트에게 다시 부여하는 방식으로 IP주소를 재사용할 수도 있다.
		    - 클라이언트 서버 프로토콜
		    - 단계
			    - DHCP DISCOVER: 새로 접속한 클라언트가 DHCP discover message 전송
				    - 출발지 주소는 0.0.0.0, 도착지 주소는 255.255.255.255 67번 포트로 전송
			    - DHCP OFFER: DHCP offer message를 클라이언트에게 제공
				    - DHCP 서버가 수신한 discover 메시지의 트랜잭션 ID, 클라이언트에 제공된 IP 주소, 네트워크 마스크, IP 주소 유효기간을 포함한다.
			    - DHCP REQUEST: DHCP 서버를 선택하여 DHCP 요청 메시지를 전송한다. 
			    - DHCP ACK: 전달받은 요청메시지에대해 DHCP 서버가 응답한다.
				    - 클라이언트가 DHCP ACK 메시지를 받으면 클라이언트는 DHCP 할당 IP 주소를 임대 기간 동안 사용할 수 있다.
	    
	    - NAT(Network Address Translation)
		    - 네트워크 주소를 효율적으로 사용할 수 있게 해주는 기술
		    - 하나의 주소로 로컬 네트워크 내의 모든 호스트들이 외부와 통신할 수 있다. 
		    - 내부 호스트는 외부 호스트와 구분될 필요가 없다.
		    - 외부에서 하나의 주소로 통신이 들어오면 내부에서 알아서 구별하여 사용할 수 있다.
		    - 내부에서 사설망 private IP로 구분한다. 내부에서만 쓰이는 비공식적인 IP 주소로 ISP에게 부여 받은 외부 통신 주소인 public IP 와 구분하여 사용할 수 있다. 
		    - 그러므로 내부에서 호스트가 직접 서버를 운영할 땐 포트포워딩 기술이 필요하다.
		     
	    - IPv6
		    - 부족한 주소 문제 때문에 등장하게 되었다.
		    - IPv4 에 비해 간결하고 간소하게 만들어졌다.
		    - 32bit에서 128bit 로 주소 크기 자체를 확장
		    - 40byte의 고정된 헤더 길이를 가진다. 고정된 길이를 가지므로 라우터가 IP 데이터그램 헤더를 더 빨리 처리할 수 있다. 
		    - 단편화/재결합은 호스트에서만 수행된다.
		    - 트랜스포트 계층 프로토콜과 데이터 링크 프로토콜이 체크섬을 이미 수행하고 있으므로 네트워크 계층에서는 생략하였다.
	    
	    - match plus action
		    - 라우팅 방식의 변화
		    - 기존의 IP 네트워크에서는 동일한 목적지의 패킷은 동일한 방식으로 forwarding 해야했었다. 
		    - SDN 네트워크에서는 각각의 패킷 스위치는 원격 컨트롤러에 의해 계산 및 분포된 매치 플러스 액션 테이블을 포함하고 있으며, 이런 원격 컨트롤러가 설정한 flow table 을 사용하여 목적지가 동일해도 서로 다른 방식으로 forwarding 할 수 있다.

- 네트워크 계층의 제어평면(control plane)
	- 제어평면은 데이터 그램이 출발지 호스트부터 목적지 호스트까지의 경로를 따라 어떻게 전달되야 하는지 제어한다. 그리고 네트워크 계층 구성 요소와 서비스를 어떻게 설정하고 관리할지도 제어한다.
	-   제어평면을 다루는 방법
	    -   전통적인 방법: 라우터별 제어
	        -   라우팅 알고리즘의 각 라우터에서 동작하면서 라우터의 포워딩 테이블의 내용을 결정한다.
	        -   각 라우터는 다른 라우터의 라우팅 구성요소와 통신하여 자신의 포워딩 테이블의 값을 계산한다.
	        -   라우터는 포워딩과 라우팅 기능을 모두 갖고 있다.
	        -   OSPF, BGP 프로토콜은 라우터별 제어 방식을 기반으로 동작한다.
	    -   현대적인 방법: 논리적 중앙 집중형 제어
	        -   SDN(Software-defined networking): 소프트웨어 정의 네트워킹
	            -   라우터와 물리적으로 분리된 중앙의 컨트롤러가 포워딩 테이블을 세팅하고 라우터는 포워딩 기능만을 수행한다.
	            -   중앙서버에서 모든 라우터들이 가지는 정보를 수집한 뒤에 그 정보를 기반으로 포워딩 테이블을 만들어주고 라우터에 전달한다.
	            -   더 많은 정보를 가지고 포워딩 테이블을 만들기 때문에 보다 효율적인 길을 선택할 수 있다는 장점이 있다.
	            -   중앙의 라우팅 컨트롤러는 라우터의 제어 에이전트(control agent, CA)와 상호작용하여 라우터의 플로우 테이블을 구성 및 관리한다.
	            -   라우터별 제어방식과는 다르게 라우터의 CA간 직접적으로 상호작용하지 않는다.
	            -   매치 플러스 액션 추상화를 통해 라우터는 기존에는 별도의 장치로 구현되었던 다양한 기능(부하분산, 방화벽, NAT)뿐만 아니라 전통적인 IP 포워딩을 수행할 수 있다.

- 라우팅 알고리즘
	- 목표
	    - 송신자부터 수신자까지 라우터의 네트워크를 통과하는 좋은 경로를 결정하는 것
         - 일반적으로 좋은 경로는 최소 비용 경로를 의미한다.
     - 종류
	     - 중앙 집중형 라우팅 알고리즘(centralized routing algorithm)
		     - 네트워크 전체에 대한 완전한 정보를 가지고 경로를 설정한다.
		     - 전체 상태 정보를 갖는 링크 상태(link-state,LS) 알고리즘이다.
		     - 각 라우터가 상태 정보 메시지를 통해 네트워크 전체 토폴로지(topology)를 구성하고 이를 바탕으로 최단 경로의 포워딩 테이블을 만드는 방식
		     - 상용 프로토콜: OSPF(Open Shortest Path First)
	     - 분산 라우팅 알고리즘(decentralized routing algorithm)
		     - 어떤 노드도 모든 링크의 비용에 대한 완전한 정보를 가지고 있지 않다.
		     - 최소 비용 경로의 계산이 라우터들에 의해 반복적이고 분산된 방식으로 수행된다.
		     - 각 노드가 네트워크 내 다른 모든 노드까지 거리(비용)의 추정값을 벡터 형태로 유지하는 거리 벡터(distance-vector, DV) 알고리즘이다.
			     - 각 라우터가 주기적으로 이웃 라우터와 라우팅 정보를 주고받음으로써 다른 노드에 이르는 거리 비용을 갱신하는 방식
		     - 각 라우터는 하나 이상의 직접 연결된 이웃으로부터 정보를 받고 계산을 수행하며, 계산된 결과를 다시 그 이웃들에게 배포하는 분산적인 방식을 사용하고 있으며, 이웃끼리 정보를 더 이상 교환하지 않을 때까지 프로세스가 지속된다는 점에서 반복적이다.
		     - 상용 프로토콜 : RIP(Routing Information Protocol)


   -  AS(autonomous system)
        -   AS란?
            -   한 관리 기관에서 관리하는 IP 네트워크의 집합, 동일한 network preifx(도메인)를 가진다.
            -   AS는 전 세계적으로 고유한 AS 번호로 식별될 수 있다.
            -   라우팅을 AS 내부 라우팅과 AS 외부 라우팅으로 구별할 수 있다.
            -   하나의 AS 내에서는 동일한 라우팅 알고리즘(AS 내부 라우팅 프로토콜(intra-AS routing protocol)) 사용해야한다.
        -   등장 배경
            -   경로계산의 복잡성을 감소시킨다.
                -   인터넷의 라우터 수가 증가함에 따라 라우팅 정보의 통신 계산 저장에 필요한 오버헤드가 걷잡을 수 없이 증가한다. 모든 라우터가 동일한 라우팅 알고리즘을 수행한다면 이들 라우터 각각에 모든 가능한 목적지로의 라우팅 정보를 저장하기 위해서 막대한 양의 메모리가 필요할 것이다.
            -   ISP는 자신의 라우터들로 구성된 네트워크를 원하는 대로 운용하거나 네트워크 내부 구성을 외부에 감추길 원했다. 조직은 자신의 내부 네트워크를 외부 네트워크에 연결하면서도 자신이 원하는 대로 네트워크를 운영하고 관리할 수 있어야 했다.
    -   인터넷 서비스 제공업자(ISP) 간의 라우팅
        -   border router(gateway router): 외부의 다른 AS와 링크를 갖는 라우터
        -   border 라우터가 통신을 할때는 동일한 프로토콜 BGP를 사용한다.
        -   BGP(Border Gateway Protocol) inter-domain routing, 특별히 Path vector protocol이라고 부른다.
        -   패킷의 목적지가 AS 외부에 존재할 때 패킷은 여러 AS를 통과하는 경로로 라우팅되어야한다. intra-AS 라우팅 알고리즘으로는 불충분하다. 하나의 라우터 내의 포워딩 테이블은 intra-AS 라우팅과 inter-AS 라우팅의 동작이 합쳐져서 구성된다.


- SDN(Software Defined Networking)
    -   SDN은 네트워크 기능을 분리하여 관리할 수 있게한다.
    -   SDN 구조의 특징
        -   플로우 기반 포워딩
            -   전통적인 포워딩은 IP 데이터그램의 목적지 주소를 기반으로 이루어진다.
            -   SDN으로 제어되는 스위치들에서의 패킷 전달은 트랜스포트 계층, 네트워크 계층, 링크 계층 헤더의 어떤 값을 기반으로 하든 이루어질 수 있다.
        -   데이터 평면과 제어 평면의 분리
            -   데이터 평면은 네트워크의 스위치들로 구성되어 있으며 상대적으로 단순하고 빠른 장치로서 자신들의 플로우 테이블 내용을 기반으로 매치 플러스 액션을 수행한다.
            -   제어 평면은 서버와 스위치들의 플로우 테이블을 결정, 관리하는 소프트웨어로 이루어진다.
        -   네트워크 제어 기능이 데이터 평면 스위치 외부에 존재
            -   제어평면은 SDN 컨트롤러와 네트워크 제어 애플리케이션들의 집합으로 이루어져 있다.
            -   SDN 컨트롤러는 정확한 상태 정보를 유지하고 이 정보를 네트워크 제어 애플리케이션들에 제공하며, 애플리케이션들이 하부 네트워크 장치들을 모니터 하고 프로그램하고 제어까지 할 수 있도록 수단을 제공한다.
        -   프로그램이 가능한 네트워크
            -   제어평면의 네트워크 제어 애플리케이션을 통해 네트워크를 프로그램할 수 있다.
            -   라우팅 네트워크 제어 애플리케이션은 SDN 컨트롤러가 갖고 있는 노드 상태 및 링크 상태 정보를 기반으로 출발지와 목적지 사이의 종단 간 경로를 결정한다.
            -   어떤 패킷을 스위치에서 막을지 결정하는 접속제어 기능도 수행할 수 있다.
            -   서버의 부하를 분산시키는 방식으로 패킷을 전달할 수도 있다.
-   Open Flow
    -   데이터 평면의 Open Flow 스위치와 제어평면의 Open Flow 스위치가 통신할 때 사용하는 프로토콜
    -   컨트롤러가 스위치의 상태를 조회하거나 설정할 수 있다.
-   인터넷 제어 메시지 프로토콜(Internet Control Message Protocol, ICMP)
    -   호스트와 라우터가 서로 간에 네트워크 계층 정보를 주고받기 위해 사용된다.
    -   주로 에러 리포팅 용도로 사용된다.
    -   예: 목적지를 찾을 수 없을 경우 라우터가 오류 발생을 알리기 위해 ICMP 메시지를 만들어서 호스트에게 보낸다.
    -   ICMP 메시지는 IP 데이터그램 위에서 동작하며 IP 페이로드로 전송된다.

## 프로세스 관리

- 프로세스란?
	- 프로세스는 실행 중인 프로그램을 의미한다. job 이라는 용어와 혼용해서 사용
	- 프로세스를 이해하기 위해서는 프로세스 문맥(context)에 대한 이해가 필요하다. 
		- 여러 프로세스가 함께 수행되는 시분할 시스템 환경에서는 CPU의 제어권을 잠깐씩 점유하여 사용하기 때문에 다시 획득해서 명령의 수행을 재개하는 시점이 되면 이전의 CPU 보유 시점에 어느 부분까지 명령을 수행했는지 직전 수행 시점의 정확한 상태를 재현할 필요가 있다.
		- 프로세스의 문맥은 그 프로세스의 주소 공간을 비롯해 레지스터에 어떤 값을 가지고 있었는지와, 시스템 콜 등을 통해 커널에서 수행한 일의 상태, 그 프로세스에 관해 커널이 관리하고 있는 각종 정보 등을 포함하게 된다.
		- 프로세스 문맥을 크게 3가지로 분류
			- 하드웨어 문맥
				- CPU의 수행상태를 나타내는 것으로 프로그램 카운터값과 각종 레지스터에 저장하고 있는 값들을 의미한다.
			- 프로세스의 주소 공간
				- 프로세스는 코드, 데이터, 스택으로 구성되는 자기 자신만의 독자적인 주소 공간을 가지고 있다.
			- 커널상의 문맥
				- 운영체제는 프로세스를 관리하기 위한 자료 구조인 PCB와 커널 스택을 유지한다.

- 프로세스의 상태
	- 분류
		- 시작
			- 프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태
		- 실행(running)
			- 실행 상태는 프로세스가 CPU를 보유하고. 기계어 명령을 실행하고 있는 상태
			- 실행 시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정을 context switch 라고 한다.
		- 준비(ready)
			- 프로세스가 CPU만 보유하면 당장 명령을 실행할 수 있지만 CPU를 할당받지 못한 상태
			- 인터럽트가 발생하거나 실행 중이던 프로세스가 봉쇄상태로 바뀌는 경우 준비 상태에 있는 프로세스들 중에서 CPU를 할당받을 프로세스를 선택한 후 실제로 CPU의 제어권을 넘겨받는 과정을 CPU dispatch라고 한다.
		- 봉쇄(blocked, wait, sleep)
			- CPU를 할당받더라도 당장 명령을 실행할 수 없는 프로세스의 상태
		- 완료
			- 프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태
		- 중지
			- 외부적인 이유로 프로세스의 수행이 정지된 상태 (inactive)
			- 중지 상태에 있는 프로세스는 외부에서 재개시키지 않는 이상 다시 활성화될 수 없으므로 메모리 자원이 필요하지 않기 때문에 중지 상태 프로세스의 메모리는 통째로 디스크로 스왑 아웃된다.
			- 중지준비(suspended ready)
			- 중지봉쇄(suspended blocked)

- 프로세스의 제어블록(Process Control Block)
	- PCB는 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조
	- 구성
		- 운영체제가 관리상 사용하는 정보
			- 프로세스의 상태, 프로세스 번호, 스케줄링 정보, 우선순위
		- CPU 수행 관련 하드웨어 값
			- 프로그램 카운터, 레지스터
		- 메모리 관련
			- 코드, 데이터, 스택의 위치 정보
		- 파일 관련
			- 프로세스가 오픈한 파일 정보

- 문맥 교환(context switch)
	- 문맥 교환이란 하나의 사용자 프로세스로부터 다른 사용자 프로세스로 CPU의 제어권이 이양되는 과정을 뜻한다.
	- 문맥 교환 중에 이전 프로세스는 프로세스 문맥을 자신의 PCB에 저장하고, 새롭게 CPU를 할당받을 프로세스는 예전에 저장했던 자신의 문맥을 PCB로부터 실제 하드웨어로 복원시키는 과정을 거친다.
	- 하나의 사용자 프로그램이 인터럽트나 시스템 콜이 발생할 경우 CPU의 제어권이 잠시 운영체제로 넘어갔다가 돌아오는 것은 문맥 교환이라고 하지 않는다. 
	- 문맥 교환에 소요되는 시간은 시스템 입장에서 일종의 오버헤드라고 할 수 있다. 문맥교환 중에 일어나는 작업은 실제 시스템에게 유용한 작업이 아니기 때문이다. 타이머에 CPU 할당 시간을 아주 작게 세팅하면 문맥교환이 빈번하게 발생하면 이에 드는 오버헤드가 상당히 커진다. 또 그 반대로 CPU 할당 시간을 너무 길게 설정하면 시분할 시스템의 의미가 퇴색하므로 적절한 CPU 할당시간을 정하는 것이 중요하다.

- process ready queue
	- 운영체제는 준비 상태에 있는 프로세스들을 줄 세우기 위해 큐를 두고 큐의 제일 앞에 줄 서 있는 프로세스에 제일 먼저 CPU를 할당한다.
	- 운영체제는 커널의 주소 영역 중 데이터 영역에 다양한 queue를 두어 프로세스의 상태를 관리한다.
	- 큐에 프로세스를 줄 세우는 방법은 CPU 스케줄링 방법에 따라 달라진다.
	- 큐는 각 프로세스의 PCB를 연결 리스트 형태로 관리하며 포인터를 사용해 순서를 정한다.
	- device queue
		- 운영체제는 특정 자원을 기다리는 프로세스들을 줄 세우기 위해 자원별로 장치 큐를 둔다.
		- Disk I/O queue, keyboard I/O queue...
	- job queue
		- 시스템 내의 모든 프로세스를 관리하기 위한 큐
		- 프로세스의 상태와 무관하게 현재 시스템 내에 있는 모든 프로세스가 작업 큐에 속하게 된다.

- 스케줄러(scheduler)
	- 스케줄러란 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭한다.
	- 장기 스케줄러(long term, job)
		- 어떤 프로세스를 준비 큐에 진입시킬지 결정하는 역할
		- 준비 큐는 CPU만 얻으면 당장 실행될 수 있는 프로세스의 집합이고, CPU에서 실행되기 위해서는 프로세스가 메모리를 보유해야 하므로 장기 스케줄러는 프로세스에게 메모리를 할당하는 문제에도 관여한다.
		- 수십 초 내지 수 분 단위로 가끔 호출되므로 단기 스케줄러에 비해 상대적으로 수행 속도가 느리다.
		- 과거에 자원이 매우 빈약하던 시절에 사용되었으며 현재 장기 스케줄러를 두지 않는게 대부분이다. 과거에는 적은 양의 메모리를 많은 프로세스들에게 할당하면 시스템 효율이 매우 떨어졌기 때문에 메모리에 동시에 올라가 있는 프로세스의 수를 조절하는 역할을 담당했다. 현재는 프로세스가 시작 상태가 되면 장기 스케줄러 없이 곧 바로 그 프로세스에 메모리를 할당해 준비 큐에 넣는다.

	- 중기 스케줄러(medium term)
		- 현재는 장기 스케줄러 대신 중기 스케줄러를 두는 경우가 많다.
		- 너무 많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 경우 이를 해결하기 위해 메모리에 적재된 프로세스의 수를 동적으로 조절하는 역할을 한다.
		- 프로세스당 보유 메모리양이 지나치게 적어진 경우 이를 완화시키기 위해 일부 프로세스를 메모리에서 디스크로 스왑 아웃시키는 역할을 수행한다.
		- 스왑아웃 시키는 대상의 0 순위는 봉쇄 상태에 있는 프로세스들이다. 그래도 메모리 공간이 부족한 경우 보통 타이머 인터럽트가 발생해 준비 큐로 이동하는 프로세스를 추가적으로 스왑 아웃 시켜서 당장 실행되는 프로세스가 사용할 메모리 공간을 확보한다.

	- 단기 스케줄러(short term, CPU scheduler)
		- 준비 상태의 프로세스 중에서 어떤 프로세스를 다음 번에 실행 상태로 만들 것인지 결정한다.
		- 타이머 인터럽트가 발생하면 단기 스케줄러가 호출된다.
		- 밀리초 정도의 시간 단위로 매우 빈번하게 호출되므로 빠른 수행 속도가 요구된다.
- 

		    


