# 운영체제와 정보기술의 원리

운영체제란?
- 컴퓨터를 지배하는 가장 체계적인 소프트웨어
- 컴퓨터 하드웨어 바로 윗단에 설치된다.
- 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층이다.
- 컴퓨터의 전원을 키면 운영체제가 동시에 실행되고 운영체제도 소프프트웨어이므로 동시에 메모리에 올라간다. 이때 메모리에 올라가는 꼭 필요한 부분은 커널(kernel)이라고 한다. 커널은 운영체제의 핵심적인 부분이며 나머지 부분은 필요할 때 메모리로 올려서 사용한다.

운영체제의 기능
- 기본적인 역할
	- 하드웨어를 위한 역할
		- 사용자가 직접 다루기 힘든 각종 하드웨어를 운영체제가 관리한다.
		- 시스템 내의 자원을 효율적으로 관리한다.
		- 운영체제는 자원 관리자(resource manager)라고 부르기도 한다.
		- 이 때 자원은 CPU, 메모리, 하드디스크, 각종 소프트웨어를 의미한다. 
		- 운영체제는 이러한 자원을 효율적으로 관리하여 가장 좋은 성능을 내도록 한다. 
		- 어떻게 효율적으로 좋은 성능을 낼 수 있을까?
		- 어떻게 자원을 형평성 있게 분배할 수 있을까?
	- 사용자를 위한 역할 
		- 사용자에게는 편리한 인터페이스를 제공한다.
		- 시스템을 편리하게 사용할 수 있는 환경을 제공한다.

운영체제 분류
- single tasking
	- 한번에 하나의 프로그램만 실행 가능
- multitasking
	- 여러 프로그램이 CPU와 메모리를 공유해서 작업한다.
	- time sharing system (시분할 시스템)
		- 여러 프로그램들이 CPU에서 번갈아 실행되면 사용자 입장에서 동시에 실행되는 것처럼 보인다.
		- CPU의 작업시간을 여러 프로그램이 조금씩 나누어 사용한다.
- multi-programming system
	- 여러 프로그램을 동시에 메모리에 올려놓고 처리하는 시스템
- interactive system (대화형 시스템)
	-  사용자는 입력 결과를 실시간으로 확인할 수 있다.
- multi-processor system (다중처리기 시스템)
	- 하나의 컴퓨터에 여러 CPU가 설치되어 동작한다.
	- 여러 프로그램이 동시에 실행되어 속도가 빠르지만 여러 CPU를 관리하기 위해 복잡한 매커니즘을 필요로 한다.
- 다중 사용자에 대한 동시 지원 여부
	- 단일 사용자용 운영체제
		- dos, window
	- 다중 사용자용 운영체제
		- 웹 서버, 이메일 서버
- 작업 처리 방식
	- batch 방식 
		- 요청된 작업을 일정량씩 모아서 한번에 처리하는 방식
		- 사용자 입장에서 응답시간이 길어진다.
	- 시분할 방식
		- 여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용하는 방식
		- 사용자 입장에서 응답시간이 짧다.
	- 실시간 방식
		- 실시간 운영체제는 정해진 시간 안에 어떠한 일이 반드시 처리됨을 보장해야하는 시스템에서 사용됨.
		- hard realtime system
			- 주어진 시간을 지키지 못할 경우 매우 위험한 결과를 초래할 가능성이 있는 시스템
			- 로켓, 원자로 제어시스템
		- soft realtime system
			- 데이터가 정해진 시간 단위로 전달되어야 올바른 기능을 수행할 수 있는 시스템
			- 멀티미디어 스트리밍 시스템

운영체제의 자원 관리 기능

- 하드웨어 자원
	- CPU
		- 어떤 프로그램에 CPU를 할당할 것인가? (CPU 스케줄링)
		- CPU를 효율적으로 사용하면서도 특정 프로세스가 불이익을 당하지 않도록 하는 것이 목표이다.
		- 선입선출(First Come, First Served)
		- 라운드 로빈 (Round Robin)
			- CPU를 한번 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한하고 작업을 다 처리하지 못하더라도 제한 시간이 지나면 CPU 대기열의 맨 뒤로 가서 대기한다.
		- 우선순위(Priority)
	- Memory
		- 한정된 메모리를 어떻게 나누어 사용할 것인가? 
		- 메모리는 CPU가 직접 접근할 수 있는 컴퓨터 내부의 기억장치이다.
		- 프로그램이 CPU에서 실행되려면 해당 부분이 메모리에 올라가 있어야 한다.
		- 운영체제는 메모리의 어느 부분이 어떤 프로그램에 의해 사용되고 있는지를 파악하여 유지하고 관리한다. address(주소)를 통해 관리된다.
		- 운영체제는 프로그램에 메모리가 필요할 때 할당하고, 더 이상 필요하지 않을 때 회수한다.
		- 운영체제는 각 프로세스가 자신의 메모리 영역에만 접근할 수 있게 관리하는 역할도 수행한다.
		- 고정 분할(fixed partition)
		- 가변 분할(variable partition) 
		- 가상 메모리(virtual memory)
	- 보조기억장치
		- 디스크에 파일을 어떻게 보관할 것인가?
	- 입출력 장치
		- 각기 다른 입출력 장치와 컴퓨터 간에 어떻게 정보를 주고 받을 것인가?
		- interrupt 매커니즘을 통해 관리된다.
		- 주변 장치들은 해당 장치에서 일어나는 업무를 관리하기 위해 일종의 작은 CPU인 controller(제어기)를 가지고 있다.
		- 사용자로부터 입력이 들어오면 키보드 컨트롤러가 interrupt 신호를 CPU에게 신호를 발생시킨다. 
		- CPU는 인터럽트 신호가 발생하면 수행하던 작업을 임시 저장 후 인터럽트 신호를 발생시킨 작업을 수행한다. 
		- 운영체제는 인터럽트의 종류마다 서로 다른 인터럽트 처리 루틴은 운영체제 커널 내에 존재하는 코드로 가지고 있다. 
		- 인터럽트가 발생하면 운영체제는 해당하는 인터럽트 처리루틴을 찾아서 정의된 코드에 따라 일을 수행하게 된다.
- 소프트웨어 자원


## 컴퓨터 시스템의 동작 원리

- 컴퓨터 시스템의 구조
	- 내부장치
		- 컴퓨터는 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행한 후 그 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리한다.
		- CPU
		- 메모리
	- 외부장치
		- 입출력 장치
			- 입출력 장치마다 이를 제어하기 위해 설치된 장치 컨트롤러는 장치로 부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리인 로컬 버퍼local buffer 를 가지고 있다.
			- 로컬 버퍼로 다 읽어 오면 컨트롤러가 인터럽트 신호를 발생시켜 CPU에 보고한다.
			- CPU는 작업 도중 인터럽트 라인에 신호가 들어오면 하던 일을 멈추고 인터럽트와 관련된 일을 먼저 처리한다. 명령 하나를 수행할 때마다 인터럽트가 발생했는지 확인한다.

- CPU 연산과 I/O 연산
	- CPU 연산과 입출력 장치들의 I/O 연산은 동시에 수행가능하다.
	- 기본적으로 CPU는 매 시점 메모리에서 명령(instruction)을 하나씩 읽어와서 수행한다.

- 인터럽트
	- 하드웨어 인터럽트
		- 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅한다. 인터럽트 라인은 인터럽트 신호를 받는다.
	- 소트웨어 인터럽트
		- trap 이라고 불린다.
		- 소프트웨어가 CPU의 인터럽트 라인을 세팅한다. 
		- 예외 사항(exception)
			- 비정상적인 작업 시도하거나 자신의 메모리 영역 바깥에 접근을 시도하는 권한없는 작업을 시도할 때 이에 대한 처리를 위해 발생시키는 인터럽트를 말한다.
		- 시스템 콜(system call)
			- 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법이라고 볼 수 있다.
			- 사용자 프로그램이 운영체제 커널에 있는 코드를 실행하고자 할 때 인터럽트 라인 세팅을 통해 CPU 제어권을 운영체제로 넘겨 실행한다.
	- 인터럽트 핸들링 과정
		- 프로그램이 실행되고 있을 때 인터럽트가 발생하면 현재 프로그램의 상태를 저장한다.
			- 실행중인 명령의 메모리 주소값
			- 인터럽트가 발생해 새로운 명령을 실행하면 CPU 내부 임시 기억장치인 register의 기존 데이터가 지워지므로 CPU 내의 상태정보 등
			- 운영체제는 현재 시스템 내에서 실행되는 프로그램을 관리하기 위해 프로세스 제어 블록(Process Control Block, PCB) 이라는 자료구조를 둔다.
			- PCB는 각각의 프로그램마다 하나씩 존재하며 해당 프로그램의 어느 부분이 실행중이 었는지를 저장하고 있다. (프로그램이 실행중이던 코드의 메모리 주소와 레지스터값, 하드웨어 상태 등)
		- CPU의 제어권을 인터럽트 처리 루틴으로 넘겨 인터럽트 처리를 한다.
		- 처리가 끝나면 저장된 상태를 PCB로부터 CPU 상에 복원해 인터럽트 당하기 직전의 위치부터 실행이 이어지게 된다.
		- 오늘날 운영체제는 인터럽트가 발생할 때에만 실행된다.
		- 운영체제는 인터럽트가 발생했을 때에만 잠깐 CPU의 제어권을 획득할 수 있다. 
		- 사용자 프로그램은 인터럽트가 발생하지 않으면 원하는 만큼 CPU를 계속 점유하고 있게 된다. 

### 입출력 구조

- 입출력(I/O)란 컴퓨터 시스템이 컴퓨터 외부의 입출력 장치들과 데이터를 주고받는 것을 말한다. 
- 방식
	- 동기식 입출력
		- 입출력 작업이 완료된 후에 프로그램이 후속 작업을 수행할 수 있는 방식
		- CPU는 입출력 연산이 끝날 때까지 인터럽트를 기다리면 자원을 낭비하게 된다.
		- 이러한 낭비를 막기 위해 입출력 작업 수행 중인 경우 CPU를 다른 프로그램에게 이양해 계속 일할 수 있도록 관리한다.
		- 입출력 중인 프로그램을 Blocked State로 전환하여 관리한다. 
		- 동기식 입출력 요청의 동기화를 위해 장치별로 queue를 두어 요청한 순서대로 처리한다.
		- 입출력 연산이 끝나면 인터럽트가 CPU에게 신호를 주고 운영체제 커널은 인터럽트 처리루틴으로 가서 입출력 연산을 끝낸 프로그램이 CPU를 할당받을 수 있도록 프로그램의 blocked state 를 해제시킨다.
		- 일반적으로 운영체제는 보통 동기식 입출력을 사용하여 동기성을 보장하게 한다.
	
	- 비동기식 입출력
		- 입출력 연산을 요청한 후에 대기하지 않고 CPU 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여한다.
		- 입출력 연산 작업과 관계없는 다른 작업을 병행하여 수행할 수 있다.
		- 입출력 작업이 끝나면 끝난 시점부터 읽어온 데이터를 필요로 하는 명령을 수행할 수 있게된다.

### DMA(Direct Memory Access)
- 원칙적으로 메모리는 CPU에 의해서만 접근할 수 있는 장치이다. CPU 외의 장치가 메모리의 데이터에 접근하기 위해서는 CPU에게 인터럽트를 발생시켜 CPU가 이를 대행하는 식으로만 가능하다.
- 하지만 모든 메모리 접근 연산이 CPU에 의해서만 이루어질 경우 입출력 장치가 메모리 접근을 원할 때마다 인터럽트에 의해 CPU의 업무가 방해를 받게되어 효율성이 감소하기 때문에 CPU 이외의 메모리 접근 가능 장치인 DMA를 두는 경우가 많다.
- DMA를 사용하면 CPU에 발생하는 인터럽트를 줄일 수 있다. 
- DMA를 사용하게 되면 로컬 버퍼에서 메모리로 읽어오는 작업을 CPU 대신 수행한다.
- DMA는 byte 단위가 아니라 block이라는 큰 단위로 정보를 메모리로 읽어온 후에 CPU에게 인터럽트를 발생시킨다.

### 저장 장치

-   구조
    -   주 기억 장치
        -   메모리
        -   전원이 나가면 저장된 내용이 사라지는 휘발성 RAM
    -   보조 기억 장치
        -   전원이 나가도 저장된 내용을 기억할 수 있는 비휘발성
        -   파일 시스템 용도로 사용
        -   메모리의 연장 공간인 swap area (스왑영역) 용으로 사용
        -   운영체제가 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분은 디스크의 swap area에 내려놓고 사용한다.
-   계층 구조
    -   속도가 빠른 저장장치는 가격이 높아서 적은 용량으로 사용하게 된다. 속도가 느린 저장 장치는 가격이 싸서 많은 용량으로 사용하게 된다.
    -   당장 필요한 정보는 빠른 저장장치에 넣어두어 빠르게 사용할 수 있게 하고 그렇지 않은 정보는 느린 저장장치에 저장하여 사용한다.
    -   빠른 저장장치에 빈번하게 사용되는 정보를 저장하면 필요한 정보를 빠른 저장장치에서 곧바로 찾아서 사용할 수 있기 때문에 전체적인 성능이 향상된다.

### 하드웨어의 보안

-   운영체제는 하드웨어의 보안을 유지하기 위해 커널모드(kernel mode, system mode)와 사용자 모드(user mode) 2가지 모드를 지원한다.
-   중요한 정보에 접근할 수 있는 연산은 커널모드에서만 수행한다. 일반적인 연산만 사용자 모드에서 사용자 프로그램이 수행할 수 있게 허용한다.
-   커널 모드
    -   운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행.
    -   제한 없이 모든 명령 실행 가능
    -   인터럽트가 발생할 때 CPU의 제어권이 다시 운영체제로 넘어오면 mode bit는 자동으로 0이 세팅된다.
    -   모든 입출력 명령은 커널모드에서만 실행 가능하다. 사용자모드에서 입출력이 필요할 때 운영체제에 대신 요청해야 수행가능하다.(system call)
-   사용자모드
    -   사용자 프로그램은 제한적인 명령만 수행 가능
    -   사용자 프로그램이 CPU를 가지고 있는 동안에 운영체제가 사용자 프로그램을 감시하기 위해 컴퓨터 시스템 CPU 내부에 mode bit를 두고 있다. mode bit 가 0으로 세팅되어 있을 때만 커널모드로 모든 명령을 수행가능하다. CPU는 보안 관련 명령을 수행하기 전에는 항상 mode bit를 조사해 그 값이 0으로 세팅되어 있을 때만 수행한다.

### 메모리의 보안

-   사용자 프로그램이 다른 사용자 프로그램의 메모리 영역이나 운영체제 커널이 위치한 메모리 영역을 참조하려는 시도를 차단해야한다.
-   하나의 프로그램이 메모리의 한 영역에 연속적으로 위치하는 단순화된 메모리 관리기법을 사용하는 경우에 2개의 레지스터를 사용해서 프로그램이 접근하려는 메모리 부분이 합법적인지 체크함으로써 메모리를 보호할 수 있다. 운영체제는 2개의 레지스터 값을 직접 세팅할 수 있고 사용자 프로그램은 세팅할 수 없다.
-   하나의 프로그램이 메모리의 여러 영역에 나뉘어 위치하는 페이징(paging) 기법을 사용할 경우 추가적인 방법이 필요하다.
-   메모리 접근 연산이 있을 때마다 체크한다. 잘못된 메모리 영역을 참조하려는 시도는 예외를 발생시키고, 운영체제로 CPU의 제어권을 넘긴 후 해당 프로그램을 강제로 종료시킨다.
    -   기준 레지스터
        -   기준 레지스터는 어떤 프로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리상의 가장 작은 주소를 보관하고 있다.
    -   한계 레지스터
        -   한계 레지스터는 그 프로그램이 기준 레지스터값부터 접근할 수 있는 메모리의 범위를 보관하고 있다.

### CPU의 보안

-   CPU가 하나의 프로그램에 의해 독점되는 것을 막기 위해 운영체제는 timer라는 하드웨어를 사용한다.

### 시스템 콜을 이용한 입출력 수행

-   입출력 명령은 운영체제만 수행할 수 있는 명령이다.
-   사용자 프로그램은 직접 입출력을 수행하는 대신 운영체제에게 시스템 콜이라는 서비스 대행요청을 하여 입출력을 수행한다.
-   시스템 콜은 소프트웨어적인 인터럽트로서 사용자 프로그램이 시스템 콜을 할 경우 트랩이 발생해 CPU의 제어권이 운영체제로 넘어가게 된다.
		


## 프로그램의 구조와 실행

### 프로그램의 구조와 인터셉트
- 프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야 한다.
- 프로그램의 주소 영역 
	- code
		- 우리가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 부분이다.
	- data
		- 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분이다.
	- stack
		- 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데에 사용되는 공간이다.
		- CPU가 함수를 실행하다가 다른 함수를 호출하면 다른 함수의 코드로 수행 위치를 이동하여 실행하고 수행을 마치고 다시 돌아와야 하는 복귀 주소를 스택에 저장한다.
		- 인터럽트의 동작 원리도 함수 호출과 유사하다. 인터럽트 발생시 복귀주소는 각 프로그램의 주소 공간 중 스택에 저장한다. 
		- 인터럽트 발생시 CPU를 빼앗긴 시점의 위치는 운영체제가 관리하는 프로세스 제어블록에 저장된다. 프로세스 제어 블록에는 인터럽트가 발생한 시점에서 그 프로그램의 어느 부분까지 수행했는지를 저장하며, 인터럽트 처리 후 프로세스 제어블록에 저장된 주소를 복원시켜 원래 수행하던 일을 재개하게 된다.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
