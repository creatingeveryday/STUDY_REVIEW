## 📘  헤드퍼스트 디자인패턴

- 디자인 패턴은 코드가 아닌 경험을 재사용하는 것이다?
- 소프트웨어를 유지 보수 할 때 기존 코드에 미치는 영향을 최소한으로 줄이면서 작업할 수 있다면?
- 좋은 객체지향 소프트웨어 디자인 원칙이란? 
- 애플리케이션의 변화와 성장에 어떻게 대응할 것인가? 
- 시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있는가? 
- 어떤 문제를 해결하기 위해서 어떻게 클래스와 객체를 구성해야하는가?
- 아래의 질문에 대한 좋은 아이디어가 패턴화된 것 같다.
	-   어떻게 코드를 더 많이 재사용할 수 있을까?
	-   어떻게 변화에 대처하여 코드 작업량을 최소화할 수 있을까?
	-   어떻게 변화의 전파를 최소화할 수 있을까?
	-   어떻게 시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있을까?
	-   어떻게 쉽게 확장할 수 있을까?
	-   어떻게 코드를 읽기 쉽고 상식적이고 직관적으로 이해할 수 있게 만들 수 있을까?

### 디자인원칙
0. 문제를 명확히 파악하기! 미리 요구사항 검토 및 분석!
1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다. 
	- 바뀌는 부분을 따로 캡슐화 한다. 바뀌지 않는 부분에 영향을 미치지 않고 수정할 수 있다. 
	- 변화에 어떻게 대처할 것인가?
	- 어떻게 중복을 제거하고 유지보수를 쉽게할 수 있을까? 
2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다. 상위 형식(super type)에 맞춘다.
	- 구체적으로 구현할 필요가 없으면 즉, 의존하지 않으면 유연하게 행동을 변경하기 쉽다.
3. 상속보다는 구성(composition)을 활용한다.
	- 캡슐화, 인터페이스를 활용하여 실행시에 객체의 행동을 동적으로 바꿀 수 있다.
	- 상속에는 단점이 존재한다.
		- 캡슐화 위반
		- 설계의 유연성 감소
			- 불필요한 중복 발생
			- 상속관계는 컴파일 타임에 결정되고 고정됨 => 여러 기능이 조합된다면 별도의 클래스를 추가해야함. 
			- 또 모든 서브 클래스에서 불필요하더라도 똑같은 행동을 상속받아야하는 문제가 있다. 
			- 실행중에 동적으로 행동을 설정할 수 없다. 
4. 상호작용하는 객체 사이에는 가능하면 느슨한 결합(Loose Coupling)을 사용해야한다.
	- 객체 사이의 상호의존성을 최소화
5. 클래스는 확장에는 열려있지만 변경에는 닫혀있어야 한다 : OCP
	- 디자인한 것 중에서 가장 바뀔 가능성이 높은 부분부터 OCP를 적용하는게 좋다.  
6. 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다. (의존성 뒤집기 원칙, Dependency Inversion Principle)
	- 의존성 뒤집기 원칙 가이드라인
	- 변수에 구상 클래스의 레퍼런스를 저장하지않는다. 
		- 바뀔 수 있는 부분은 팩토리 메소드 패턴을 써서 바뀌는 부분을 캡슐화해야한다. 
	- 구상 클래스에서 유도된 클래스를 만들지 않는다.
		- 특정 구상 클래스에 의존하는 것을 피하자. 추상화된 것으로부터 클래스를 만들어야 한다.
	- 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드 하지 않는다.
		- 베이스 클래스에는 메소드를 정의할 때는 모든 서브 클래스에서 공유할 수 있는 것만 정의해야 한다.
7.  

### 전략패턴
- 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸수 있게 해준다. 
- 전략패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.
- 실행 중에도 확장과 변경이 용이하다.

### 옵저버 패턴
- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.
- 주제 ~> 옵저버
- 주제 인터페이스 ~> 옵저버 인터페이스
- 주제가 데이터를 한 곳에서 저장하고 제어한다.
- 주제는 옵저버가 Observer 인터페이스를 구현한다는 사실만 알면된다.
- 옵저버는 언제든지 추가, 삭제할 수 있다.
- 새로운 형식의 옵저버가 추가되더라도 옵저버 인터페이스를 구현하면 어떤 객체와도 상호 작용할 수 있다. 
- 주제와 옵저버는 서로 독립적으로 재사용할 수 있다.
- 주제의 데이터가 변경시 옵저버로 데이터를 보내는 push 방식
- 옵저버가 값이 바뀌었다는 알림을 받을 때 주제로부터 데이터를 당겨오는 pull 방식
- 주제의 상태와 옵저버의 개수, 형식 정도만 바뀌고 주제의 상태에 의존하는 객체 변경 가능.
- 

### 데코레이터 패턴
- 데코레이터 패턴으로 객체에 추가 요소(책임)를 동적으로 추가할 수 있다. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다. 상속 대신 데코레이터 패턴을 이용해보는건 어떨까? 
	- 상속을 남용하면 복잡하고 끔찍한 스파게티 코드를 만들 수 있다.
	- 기존 객체에 바뀌는 부분을 어떻게 다뤄야할까? 미래에 새로운 부분이 추가되어야 한다면? 새로운 로직이 추가된다면? 
	- 어떻게 기존 코드에 미치는 변화를 최소화하거나 변경하지 않고 새로운 기능을 추가할 수 있을까? 
- 데코레이터 패턴으로 객체에 추가 요소를 동적으로 추가할 수 있다. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다.
- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다. 
- 한 객체를 여러개의 데코레이터로 감쌀 수 있다.
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체가 들어갈 자리에 데코레이터 객체를 넣어도 상관이 없다. 
- 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있다. 
- 객체는 언제든지 감쌀 수 있으므로 실행중에 필요한 데코레이터를 마음대로 적용할 수 있다.
- 데코레이터 객체를 구성해서 새로운 행동을 추가할 수 있다. (상속받아서 얻는 방식을 사용하지 않는다.)
- 데코레이터 패턴을 쓰면 관리해야될 객체가 늘어난다. 그러나 이럴 때 팩토리패턴이나 빌더패턴을 이용해 데코레이터를 만들어서 사용하면 좋다. 
- Java의 I/O API는 데코레이터 패턴을 바탕으로 만들어졌다. 왜 그런 방식으로 코드가 작성되는지 조금은 알 것 같다. 정말 다양한 조합이 가능한 상황이 자주 만들어지기 때문에 이런 유연한 설계가 필요했구나 싶다. 
- 데코레이터 패턴에는 단점도 존재한다.
	- 자잘한 클래스가 엄청나게 많이 추가될 수 있어서 이해하기 힘든 디자인이 만들어질수도 있다. 
	- 특정한 형식에 의존하는 클라이언트 코드에 적용하기가 어렵다. ( 사실 클라이언트는 데코레이터를 사용하고있다는 사실을 몰라도 된다.) 
	- 구성요소를 초기화하는데 필요한 코드가 훨씬 복잡해진다.

### 팩토리 패턴: 객체 생성을 캡슐화 / 클라이언트와 구상 클래스를 분리
1. 팩토리 메소드 패턴 : 객체를 생성할 때 필요한 인터페이스를 만들고 구체적인 구현은 서브 클래스에서 수행한다. 서브클래스에 따라 생산되는 객체 인스턴스가 결정되는 구조이다.
		- 팩토리 메소드 패턴은 서브 클래스에서 어떤 클래스를 만들지 결정함으로써 객체 생성을 캡슐화합니다.
		- 추상화된 클래스(클라이언트)는 어떤 객체가 만들어질지 미리 알 수 없다. 단지 역할만을 기대할 뿐.
		- new 연산자는 인터페이스가 아닌 특정 구현을 사용하는 방식으로 변화에 유연하지 못한 방식이다.
		- 확장에 열려있는 방식으로 수정됨.
	- 객체 생성 부분을 캡슐화해서 객체 생성 팩토리 클래스를 만든다. 
	- 클라이언트는 객체 생성 팩토리로부터 객체를 전달 받는다. 클라이언트는 어떤 객체를 전달 받을 지 알 수 없다. 
	- 클라이언트와 관련된 객체 생성 팩토리를 하나로 묶어서 유연하게 관리하면 훨씬 편할 것이다.
	- 수 많은 객체를 생성할 때 관리하기 편한 패턴 인 것 같다. 미리 잘 만들어놓으면 편리하고 직관적으로 재사용가능하다.
	- 서브클래스에서 객체를 생성하는 팩토리 매서드를 구현하여 관리한다면? 
	- 적용된 디자인 원칙
		- 애플리케이션에서 달라지는 부분과 달라지지 않는 부분을 분리하여 따로 관리한다. 
		- 구현보다는 인터페이스에 맞춘다.
		- 상호작용하는 객체 사이에 느슨한 결합이 적용되어있다.
		- 클래스는 확장에는 열려있지만 변화에는 닫혀있다.
	- 객체 생성 코드를 한 곳에서 관리할 수 있어서 중복을 제거할 수 있다. 
	- 객체 의존성에 대해 생각해보기
		- 객체 인스턴스를 직접 생성하면 구상 클래스에 의존하는 문제점 존재
		- 추상화 정도가 높은 요소가 추상화 정도가 낮은 요소에 의존하게 되면 어떤 문제가 발생할까?
	- 팩토리 메소드 패턴은 추상 팩토리 패턴에 비해 간단하고 새로운 구상 클래스를 보다 쉽게 만들 수 있다.
	햣 
2. 추상 팩토리 패턴
	- 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 의루어진 제품군을 생산하는 인터페이스를 제공할 수 있다. 구상클래스는 서브클래스에서 만든다.
	- 새로운 제품을 추가할때는 인터페이스 자체를 바꿔야한다. 
	- 서로 연관된 일련의 제품군을 만들때 보다 유리한 방식 인 것 같다.
	- 
### 싱글턴 패턴
- 왜 객체를 하나만 만들어야 할까? 
- 싱글턴 패턴을 사용하면 객체 인스턴스를 전역적으로 접근할 수 있게 만들 수 있다. 
- 멀티 스레드 환경에서 싱글턴을 사용하여 만든 객체 인스턴스가 1개 이상 만들어 질 수 있을까? 
- 멀티 스레드 환경에서 어떻게 1개만 생성되도록 보장할 수 있을까?
	- getInstance 메소드 동기화
	- 인스턴스를 시작하자마자 만든다.
	- DCL을 사용하여 인스턴스가 생성되어 있지 않았을 때만 동기화 - volatile
- 어떤 방법이 적절할까?
- 싱글턴 패턴은 특수한 상황에서 제한된 용도로 사용하려고 만들어 진 것이다. 
- 동기화 문제
- 클래스 로딩 문제
- 리플렉션 문제
- 직렬화, 역직렬화시 문제
- enum으로 싱글턴을 생성하면 많은 문제 해결 가능!
	- 인스턴스가 JVM 내부에 오로지 1개만 생성된 것을 보장할 수 있음.
		
### 커맨드 패턴
-   작업을 요청하는 쪽과 작업을 처리하는 쪽을 분리해서 캡슐화한다면?
-   커맨드 객체는 Command 인터페이스를 구현하며, 일련의 행동을 특정 리시버와 연결함으로써 요청을 캡슐화한다.
-   Command 퍼블릭 인터페이스의 execute 메서드만으로 모든 객체들의 제어가 가능해진다.
-   커맨드 패턴을 사용하면 요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있다. 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수도 있다.
-   Null 객체 활용 가능: 딱히 리턴할 객체도 없고 클라이언트가 null을 처리하지 않게 하고 싶을 때 활용.


### 반복자(iterator)패턴

-   반복을 캡슐화할 수 있을까?
-   Iterator 인터페이스를 구현한다면 다형성을 활용해서 어떤 컬렉션이든 1개의 순환문으로 처리할 수 있다.
-   반복자 패턴은 컬렉션의 구현방법을 노출하지 않으면서도 집합체 내의 모든 항목에 접근하는 방법을 제공한다.
-   각 항목에 일일이 접근할 수 있게 해주는 기능은 반복자 객체가 전담해서 책임진다.  
    
-   반복 작업을 같은 인터페이스로 처리할 수 있다.

### 컴포지트(composite) 패턴

-   반복자 하나로 모든 메뉴를 대상으로 반복작업을 처리할 수 있을까?
-   따로 관리되고 있는 메뉴를 하나로 관리하여 작업할 수 있을까?
-   컴포지트 패턴으로 객체를 트리구조로 구성해서 부분-전체 계층 구조를 구현한다.
-   클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있다. 클라이언트 측에서 사용하는 방법을 매우 단순화시킬 수 있다.
-   설계는 조금 복잡해지지만 더 유연하게 반복작업을 수행할 수 있다. 메뉴, 서브메뉴, 트리 전체를 대상으로 반복작업을 편리하게 사용할 수 있다.  
-   컴포지트 패턴에서는 계층구조를관리하는 일과 메뉴 관련 작업을 동시에 처리하는 2가지의 역할을 맡고 있다.

### 상태(State) 패턴

-   상태가 추가되도 쉽고 편리하게 수정하려면?
-   바뀌는 부분인 상태를 캡슐화한다. => 상태별 행동을 별도의 클래스에 넣어두고 각각 상태에따른 할일을 구현한다.
-   객체 내부 상태가 바뀜에 따라서 객체의 행동을 바꿔야할 때 사용한다. 각 상태 클래스에 위임된 행동을 수행한다.
-   상태 패턴은 상태 객체에 일련의 행동을 캡슐화한다. 클라이언트는 바뀌는 상태 객체를 몰라도 된다.


### 프록시(Proxy) 패턴

-   특정 객체로의 클라이언트의 접근을 대신 제어하는 프록시 객체를 제공한다.
-   실무에서는 많이 변형해서 유연하게 사용 중
-   프록시 패턴을 사용하면 원격객체, 생성하기 힘든 객체, 보안이 중요한 개체와 같은 다른 객체로의 접근을 제어하는 대리인 객체를 만들 수 있다.
-   원격 프록시는 원격 객체의 로컬 대변자 역할을 한다.
-   가상 프록시는 생성하는데 많은 비용이 드는 객체를 대신한다. 진짜 객체가 필요한 상황이 오기 전까지 객체의 생성을 미루기도 하고 객체 생성이 이미 끝났다면 생성된 객체에 직접 요청을 전달한다.
-   캐싱 프록시는 기존에 생성했던 객체들을 캐시에 저장해 뒀다가, 요청이 들어왔을 때 캐시에 저장되어 있는 객체를 리턴할 수 있다.
-   보호 프록시는 클라이언트에게 인터페이스의 일부만 제공하면서 클라이언트의 역할에 따라서 객체에 있는 특정 메소드로의 접근을 제어한다.
    -   자바의 동적 프록시: java.lang.reflect 패키지 안에 내장된 프록시 기능 활용
-   자바 RMI

### 복합 패턴

- 복합 패턴은 여러 패턴을 복합적으로 사용해서 일반적인 문제를 해결할 수 있어야한다.
- MVC 패턴
	- 옵저버, 전략, 컴포지트 패턴으로 이루어진 복합 패턴

### 디자인 패턴 실전 가이드

디자인 패턴은 특정 컨텍스트 내에서 주어진 문제의 해결책이다.
- 컨텍스트
	- 반복되는 상황
- 문제
	- 컨텍스트 내에서 이뤄야하는 목표. 컨텍스트 내의 제약조건도 포함된다.
- 해결책
	- 제약조건 속에서 누가 적용해도 목표를 이룰 수 있는 일반적인 디자인을 뜻합니다.

디자인 패턴 카탈로그
- 패턴 카탈로그에는 패턴의 용도와 패턴이 만들어진 배경, 적용할 수 있는 범위, 해결책의 디자인 및 그 해결책을 적용한 결과와 장단점과 같이 다양한 내용이 자세히 쓰여있다.
- 생성, 행동, 구조라는 3가지의 범주로 용도에 따라서 나누어서 소개한다.
	- 생성 패턴 
		- 객체 인스턴스를 생성하는 패턴으로, 클라이언트와 그 클라이언트가 생성해야하는 객체 인스턴스 사이의 연결을 끊어주는 패턴
		- 싱글턴, 빌더, 프로토타입, 팩토리 메서드, 추상 팩토리...
	- 행동 패턴 
		- 클래스와 객체들이 상호작용하는 방법과 역할을 분담하는 방법을 다루는 패턴
		- 템플릿 메서드, 인터프리터, 전략, 상태, 싱글턴, 옵저버...
	- 구조 패턴 
		- 클래스와 객체를 더 큰 구조로 만들 수 있게 구상을 사용하는 패턴
		- 데코레이터, 컴포지트, 프록시, 퍼사드, 어댑터...
- 클래스를 다루는 패턴인지 객체를 다루는 패턴인지 구분할 수도 있다.
	- 클래스 패턴
		- 클래스 사이의 관계가 상속으로 어떻게 정의되는지 다루고 클래스 사이의 관계는 대부분 컴파일 할 때 결정된다.
	- 객체 패턴
		- 객체 사이의 관계를 다루며, 객체 사이의 관계는 보통 구성으로 정의된다. 일반적으로 실행중에 관계가 결정되므로 보다 동적이고 유연하다. 
- [gof 의 디자인패턴] 책에 기본 패턴 수록

##### 패턴 적용시 주의할 점
- 디자인 패턴은 필요할 때만 써야하는 도구일 뿐이다.
- 그냥 디자인 원칙만 충실히 적용해서 간단하게 문제를 해결할 수 있는 경우 패턴을 적용할 필요가 없다.
- KISS(keep it simple) 원칙이 우선이다. 패턴을 사용하지 않고 단순하게 문제를 해결해도 좋다. 패턴이 필요할 때만 적용해야한다. 
- 디자인 패턴은 만병통치약이 아니다.
- 패턴을 사용할 때는 그 패턴이 설계한 디자인에 미칠 영향과 결과를 따져보아야한다.
- 해결해야할 문제와 제약 조건을 고려해보고 간단한 해결책으로 해결할 수 없다는 판단이 들때만 패턴을 도입을 생각해봐야한다.
- 하지만 간단한 해결책으로 문제가 해결되는 데도 시스템의 어떤 부분이 변경될 거라고 예측되는 상황에서는 디자인 패턴을 적용해야한다. 단 발생가능성이 높은 실질적인 변경이 발생하는 경우에만 적용해야 한다.
- 기존에 적용된 디자인 패턴이 더 이상 유연한 해결책이 아니고 복잡해지기만 한다면 제거해야 한다.

### 브리지 패턴
- 구현과 더불어 추상화 부분까지 변경할 수 있다.
- 추상화 부분과 구현 부분을 서로 다른 클래스 계층 구조로 분리해서 그 둘을 모두 변경할 수 있다.
- 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있다.
- 인터페이스와 실제 구현할 부분을 서로 다른 방식으로 변경해야할 때 유용하게 사용할 수 있다.

### 빌더 패턴
- 복합 객체 생성 과정을 캡슐화할 수 있다.
- 클라이언트는 추상 인터페이스에 의존하므로 구현 코드를 쉽게 바꿀 수 있다.
- 여러 단계와 다양한 절차를 거쳐 객체를 만들 수 있고 내부 구조를 캡슐화하는 유연한 디자인 패턴이다.

### 책임 연쇄 패턴
- 1개의 요청을 2개 이상의 객체에서 처리해야할 때 사용할 수 있다.
- 주어진 요청을 검토하고 처리하는 객체 사슬을 생성한다.
- 사슬에 들어있는 각 객체는 핸들러 역할을 하며 주어진 요청을 직접처리하거나 처리를 위임한다.
- 요청을 보내는 쪽과 받는 쪽을 분리하고 사슬에 들어가는 객체를 바꾸거나 순서를 유연하게 바꿀 수 있다.

### 플라이웨이트 패턴
- 하나의 인스턴스로 여러 개의 가상 인스턴스를 제공하고 싶을 때 사용한다.
- 모든 객체의 상태를 클라이언트 객체가 관리할 수 있다. 
- 실행 시에 객체 인스턴스의 개수를 줄여서 메모리를 절약할 수 있다.
- 여러 가상 객체의 상태를 한 곳에 모아둘 수 있다.
- 인스턴스를 모두 똑같은 방식으로 제어하기는 편리하지만 특정 인스턴스만 다른 인스턴스와 다르게 행동 할 수 없다는 단점이 있다.

### 중재자 패턴
- 서로 관련된 객체 사이의 복잡한 통신과 제어를 한 곳으로 집중할때 사용할 수 있다.
- 중재자 패턴을 적용하면 상태가 바뀔 때마다 중재자에게 알려준다.
- 중재자에서 보낸 요청에 응답한다. 
- 시스템과 객체를 분리할 수 있어서 재사용하기 쉬워진다.

### 메멘토 패턴
- 객체를 이전의 상태로 복구할 때 사용한다.
- 저장된 상태를 핵심 객체와는 다른 별도의 객체에 보관할 수 있어 안전하다.
- 핵심 객체의 데이터를 캡슐화된 상태로 유지할 수 있다.
- 복구 기능을 구현하는데 좋다.
- 상태를 저장하고 복구하는데 시간은 걸린다. 
