## 📘  헤드퍼스트 디자인패턴

- 디자인 패턴은 코드가 아닌 경험을 재사용하는 것이다?
- 소프트웨어를 유지 보수 할 때 기존 코드에 미치는 영향을 최소한으로 줄이면서 작업할 수 있다면?
- 좋은 객체지향 소프트웨어 디자인 원칙이란? 
- 애플리케이션의 변화와 성장에 어떻게 대응할 것인가? 
- 시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있는가? 
- 어떤 문제를 해결하기위해서 어떻게 클래스와 객체를 구성해야하는가?

### 디자인원칙
1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다. 
	- 바뀌는 부분을 따로 캡슐화 한다. 바뀌지 않는 부분에 영향을 미치지 않고 수정할 수 있다. 
2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다. 상위 형식(super type)에 맞춘다.
3. 상속보다는 구성(composition)을 활용한다.
	- 캡슐화, 인터페이스를 활용하여 실행시에 객체의 행동을 동적으로 바꿀 수 있다.
	- 상속에는 단점이 존재한다.
		- 캡슐화 위반
		- 설계의 유연성 감소
			- 불필요한 중복 발생
			- 상속관계는 컴파일 타임에 결정되고 고정됨 => 여러 기능이 조합된다면 별도의 클래스를 추가해야함. 
			- 또 모든 서브 클래스에서 불필요하더라도 똑같은 행동을 상속받아야하는 문제가 있다. 
			- 실행중에 동적으로 행동을 설정할 수 없다. 
4. 상호작용하는 객체 사이에는 가능하면 느슨한 결합(Loose Coupling)을 사용해야한다.
	- 객체 사이의 상호의존성을 최소화
5. 클래스는 확장에는 열려있지만 변경에는 닫혀있어야 한다 : OCP
	- 디자인한 것 중에서 가장 바뀔 가능성이 높은 부분부터 OCP를 적용하는게 좋다.  

### 전략패턴
- 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸수 있게 해준다. 
- 전략패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.
- 실행 중에도 확장과 변경이 용이하다.

### 옵저버 패턴
- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.
- 주제 ~> 옵저버
- 주제 인터페이스 ~> 옵저버 인터페이스
- 주제가 데이터를 한 곳에서 저장하고 제어한다.
- 주제는 옵저버가 Observer 인터페이스를 구현한다는 사실만 알면된다.
- 옵저버는 언제든지 추가, 삭제할 수 있다.
- 새로운 형식의 옵저버가 추가되더라도 옵저버 인터페이스를 구현하면 어떤 객체와도 상호 작용할 수 있다. 
- 주제와 옵저버는 서로 독립적으로 재사용할 수 있다.
- 주제의 데이터가 변경시 옵저버로 데이터를 보내는 push 방식
- 옵저버가 값이 바뀌었다는 알림을 받을 때 주제로부터 데이터를 당겨오는 pull 방식
- 주제의 상태와 옵저버의 개수, 형식 정도만 바뀌고 주제의 상태에 의존하는 객체 변경 가능.
- 

### 데코레이터 패턴
- 데코레이터 패턴으로 객체에 추가 요소(책임)를 동적으로 추가할 수 있다. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다. 상속 대신 데코레이터 패턴을 이용해보는건 어떨까? 
	- 상속을 남용하면 복잡하고 끔찍한 스파게티 코드를 만들 수 있다.
	- 기존 객체에 바뀌는 부분을 어떻게 다뤄야할까? 미래에 새로운 부분이 추가되어야 한다면? 새로운 로직이 추가된다면? 
	- 어떻게 기존 코드에 미치는 변화를 최소화하거나 변경하지 않고 새로운 기능을 추가할 수 있을까? 
- 데코레이터 패턴으로 객체에 추가 요소를 동적으로 추가할 수 있다. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다.
- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다. 
- 한 객체를 여러개의 데코레이터로 감쌀 수 있다.
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체가 들어갈 자리에 데코레이터 객체를 넣어도 상관이 없다. 
- 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있다. 
- 객체는 언제든지 감쌀 수 있으므로 실행중에 필요한 데코레이터를 마음대로 적용할 수 있다.
- 데코레이터 객체를 구성해서 새로운 행동을 추가할 수 있다. (상속받아서 얻는 방식을 사용하지 않는다.)
- 데코레이터 패턴을 쓰면 관리해야될 객체가 늘어난다. 그러나 이럴 때 팩토리패턴이나 빌더패턴을 이용해 데코레이터를 만들어서 사용하면 좋다. 
- Java의 I/O API는 데코레이터 패턴을 바탕으로 만들어졌다. 왜 그런 방식으로 코드가 작성되는지 조금은 알 것 같다. 정말 다양한 조합이 가능한 상황이 자주 만들어지기 때문에 이런 유연한 설계가 필요했구나 싶다. 
- 데코레이터 패턴에는 단점도 존재한다.
	- 자잘한 클래스가 엄청나게 많이 추가될 수 있어서 이해하기 힘든 디자인이 만들어질수도 있다. 
	- 특정한 형식에 의존하는 클라이언트 코드에 적용하기가 어렵다. ( 사실 클라이언트는 데코레이터를 사용하고있다는 사실을 몰라도 된다.) 
	- 구성요소를 초기화하는데 필요한 코드가 훨씬 복잡해진다.
	-  
