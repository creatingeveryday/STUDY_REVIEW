## 📘  헤드퍼스트 디자인패턴

- 디자인 패턴은 코드가 아닌 경험을 재사용하는 것이다?
- 소프트웨어를 유지 보수 할 때 기존 코드에 미치는 영향을 최소한으로 줄이면서 작업할 수 있다면?
- 좋은 객체지향 소프트웨어 디자인 원칙이란? 
- 애플리케이션의 변화와 성장에 어떻게 대응할 것인가? 
- 시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있는가? 
- 어떤 문제를 해결하기 위해서 어떻게 클래스와 객체를 구성해야하는가?
- 아래의 질문에 대한 좋은 아이디어가 패턴화된 것 같다.
	-   어떻게 코드를 더 많이 재사용할 수 있을까?
	-   어떻게 변화에 대처하여 코드 작업량을 최소화할 수 있을까?
	-   어떻게 변화의 전파를 최소화할 수 있을까?
	-   어떻게 시스템의 일부분을 다른 부분과 독립적으로 변화시킬 수 있을까?
	-   어떻게 쉽게 확장할 수 있을까?
	-   어떻게 코드를 읽기 쉽고 상식적이고 직관적으로 이해할 수 있게 만들 수 있을까?

### 디자인원칙
0. 문제를 명확히 파악하기! 미리 요구사항 검토 및 분석!
1. 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다. 
	- 바뀌는 부분을 따로 캡슐화 한다. 바뀌지 않는 부분에 영향을 미치지 않고 수정할 수 있다. 
	- 변화에 어떻게 대처할 것인가?
	- 어떻게 중복을 제거하고 유지보수를 쉽게할 수 있을까? 
2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다. 상위 형식(super type)에 맞춘다.
	- 구체적으로 구현할 필요가 없으면 즉, 의존하지 않으면 유연하게 행동을 변경하기 쉽다.
3. 상속보다는 구성(composition)을 활용한다.
	- 캡슐화, 인터페이스를 활용하여 실행시에 객체의 행동을 동적으로 바꿀 수 있다.
	- 상속에는 단점이 존재한다.
		- 캡슐화 위반
		- 설계의 유연성 감소
			- 불필요한 중복 발생
			- 상속관계는 컴파일 타임에 결정되고 고정됨 => 여러 기능이 조합된다면 별도의 클래스를 추가해야함. 
			- 또 모든 서브 클래스에서 불필요하더라도 똑같은 행동을 상속받아야하는 문제가 있다. 
			- 실행중에 동적으로 행동을 설정할 수 없다. 
4. 상호작용하는 객체 사이에는 가능하면 느슨한 결합(Loose Coupling)을 사용해야한다.
	- 객체 사이의 상호의존성을 최소화
5. 클래스는 확장에는 열려있지만 변경에는 닫혀있어야 한다 : OCP
	- 디자인한 것 중에서 가장 바뀔 가능성이 높은 부분부터 OCP를 적용하는게 좋다.  
6. 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다. (의존성 뒤집기 원칙, Dependency Inversion Principle)
	- 의존성 뒤집기 원칙 가이드라인
	- 변수에 구상 클래스의 레퍼런스를 저장하지않는다. 
		- 바뀔 수 있는 부분은 팩토리 메소드 패턴을 써서 바뀌는 부분을 캡슐화해야한다. 
	- 구상 클래스에서 유도된 클래스를 만들지 않는다.
		- 특정 구상 클래스에 의존하는 것을 피하자. 추상화된 것으로부터 클래스를 만들어야 한다.
	- 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드 하지 않는다.
		- 베이스 클래스에는 메소드를 정의할 때는 모든 서브 클래스에서 공유할 수 있는 것만 정의해야 한다.
7.  슈퍼클래스에서 모든 것을 관리하고 필요시 서브클래스를 불러서 사용해야한다. 
	- 이렇게 해야 의존성이 복잡하게 꼬이는 것을 방지할 수 있다.
	- 서브클래스는 슈퍼클래스에 접속할 수 있지만, 어떻게 서브클래스를 사용할지는 전적으로 슈퍼클래스가 모든 것을 결정하게 만들어서 의존성을 단순화시킨다. 

### 전략패턴
- 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸수 있게 해준다. 
- 전략패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.
- 실행 중에도 확장과 변경이 용이하다.

### 옵저버 패턴
- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.
- 주제 ~> 옵저버
- 주제 인터페이스 ~> 옵저버 인터페이스
- 주제가 데이터를 한 곳에서 저장하고 제어한다.
- 주제는 옵저버가 Observer 인터페이스를 구현한다는 사실만 알면된다.
- 옵저버는 언제든지 추가, 삭제할 수 있다.
- 새로운 형식의 옵저버가 추가되더라도 옵저버 인터페이스를 구현하면 어떤 객체와도 상호 작용할 수 있다. 
- 주제와 옵저버는 서로 독립적으로 재사용할 수 있다.
- 주제의 데이터가 변경시 옵저버로 데이터를 보내는 push 방식
- 옵저버가 값이 바뀌었다는 알림을 받을 때 주제로부터 데이터를 당겨오는 pull 방식
- 주제의 상태와 옵저버의 개수, 형식 정도만 바뀌고 주제의 상태에 의존하는 객체 변경 가능.

### 데코레이터 패턴
- 데코레이터 패턴으로 객체에 추가 요소(책임)를 동적으로 추가할 수 있다. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다. 상속 대신 데코레이터 패턴을 이용해보는건 어떨까? 
	- 상속을 남용하면 복잡하고 끔찍한 스파게티 코드를 만들 수 있다.
	- 기존 객체에 바뀌는 부분을 어떻게 다뤄야할까? 미래에 새로운 부분이 추가되어야 한다면? 새로운 로직이 추가된다면? 
	- 어떻게 기존 코드에 미치는 변화를 최소화하거나 변경하지 않고 새로운 기능을 추가할 수 있을까? 
- 데코레이터 패턴으로 객체에 추가 요소를 동적으로 추가할 수 있다. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있다.
- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다. 
- 한 객체를 여러개의 데코레이터로 감쌀 수 있다.
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체가 들어갈 자리에 데코레이터 객체를 넣어도 상관이 없다. 
- 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있다. 
- 객체는 언제든지 감쌀 수 있으므로 실행중에 필요한 데코레이터를 마음대로 적용할 수 있다.
- 데코레이터 객체를 구성해서 새로운 행동을 추가할 수 있다. (상속받아서 얻는 방식을 사용하지 않는다.)
- 데코레이터 패턴을 쓰면 관리해야될 객체가 늘어난다. 그러나 이럴 때 팩토리패턴이나 빌더패턴을 이용해 데코레이터를 만들어서 사용하면 좋다. 
- Java의 I/O API는 데코레이터 패턴을 바탕으로 만들어졌다. 왜 그런 방식으로 코드가 작성되는지 조금은 알 것 같다. 정말 다양한 조합이 가능한 상황이 자주 만들어지기 때문에 이런 유연한 설계가 필요했구나 싶다. 
- 데코레이터 패턴에는 단점도 존재한다.
	- 자잘한 클래스가 엄청나게 많이 추가될 수 있어서 이해하기 힘든 디자인이 만들어질수도 있다. 
	- 특정한 형식에 의존하는 클라이언트 코드에 적용하기가 어렵다. ( 사실 클라이언트는 데코레이터를 사용하고있다는 사실을 몰라도 된다.) 
	- 구성요소를 초기화하는데 필요한 코드가 훨씬 복잡해진다.

### 팩토리 패턴: 객체 생성을 캡슐화 / 클라이언트와 구상 클래스를 분리
1. 팩토리 메소드 패턴 : 객체를 생성할 때 필요한 인터페이스를 만들고 구체적인 구현은 서브 클래스에서 수행한다. 서브클래스에 따라 생산되는 객체 인스턴스가 결정되는 구조이다.
		- 팩토리 메소드 패턴은 서브 클래스에서 어떤 클래스를 만들지 결정함으로써 객체 생성을 캡슐화합니다.
		- 추상화된 클래스(클라이언트)는 어떤 객체가 만들어질지 미리 알 수 없다. 단지 역할만을 기대할 뿐.
		- new 연산자는 인터페이스가 아닌 특정 구현을 사용하는 방식으로 변화에 유연하지 못한 방식이다.
		- 확장에 열려있는 방식으로 수정됨.
	- 객체 생성 부분을 캡슐화해서 객체 생성 팩토리 클래스를 만든다. 
	- 클라이언트는 객체 생성 팩토리로부터 객체를 전달 받는다. 클라이언트는 어떤 객체를 전달 받을 지 알 수 없다. 
	- 클라이언트와 관련된 객체 생성 팩토리를 하나로 묶어서 유연하게 관리하면 훨씬 편할 것이다.
	- 수 많은 객체를 생성할 때 관리하기 편한 패턴 인 것 같다. 미리 잘 만들어놓으면 편리하고 직관적으로 재사용가능하다.
	- 서브클래스에서 객체를 생성하는 팩토리 매서드를 구현하여 관리한다면? 
	- 적용된 디자인 원칙
		- 애플리케이션에서 달라지는 부분과 달라지지 않는 부분을 분리하여 따로 관리한다. 
		- 구현보다는 인터페이스에 맞춘다.
		- 상호작용하는 객체 사이에 느슨한 결합이 적용되어있다.
		- 클래스는 확장에는 열려있지만 변화에는 닫혀있다.
	- 객체 생성 코드를 한 곳에서 관리할 수 있어서 중복을 제거할 수 있다. 
	- 객체 의존성에 대해 생각해보기
		- 객체 인스턴스를 직접 생성하면 구상 클래스에 의존하는 문제점 존재
		- 추상화 정도가 높은 요소가 추상화 정도가 낮은 요소에 의존하게 되면 어떤 문제가 발생할까?
	- 팩토리 메소드 패턴은 추상 팩토리 패턴에 비해 간단하고 새로운 구상 클래스를 보다 쉽게 만들 수 있다.
	햣 
2. 추상 팩토리 패턴
	- 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 의루어진 제품군을 생산하는 인터페이스를 제공할 수 있다. 구상클래스는 서브클래스에서 만든다.
	- 새로운 제품을 추가할때는 인터페이스 자체를 바꿔야한다. 
	- 서로 연관된 일련의 제품군을 만들때 보다 유리한 방식 인 것 같다.

### 싱글턴 패턴
- 왜 객체를 하나만 만들어야 할까? 
- 싱글턴 패턴을 사용하면 객체 인스턴스를 전역적으로 접근할 수 있게 만들 수 있다. 
- 멀티 스레드 환경에서 싱글턴을 사용하여 만든 객체 인스턴스가 1개 이상 만들어 질 수 있을까? 
- 멀티 스레드 환경에서 어떻게 1개만 생성되도록 보장할 수 있을까?
	- getInstance 메소드 동기화
	- 인스턴스를 시작하자마자 만든다.
	- DCL을 사용하여 인스턴스가 생성되어 있지 않았을 때만 동기화 - volatile
- 어떤 방법이 적절할까?
- 싱글턴 패턴은 특수한 상황에서 제한된 용도로 사용하려고 만들어 진 것이다. 
- 동기화 문제
- 클래스 로딩 문제
- 리플렉션 문제
- 직렬화, 역직렬화시 문제
- enum으로 싱글턴을 생성하면 많은 문제 해결 가능!
	- 인스턴스가 JVM 내부에 오로지 1개만 생성된 것을 보장할 수 있음.
		
### 커맨드 패턴
-   작업을 요청하는 쪽과 작업을 처리하는 쪽을 분리해서 캡슐화한다면?
-   커맨드 객체는 Command 인터페이스를 구현하며, 일련의 행동을 특정 리시버와 연결함으로써 요청을 캡슐화한다.
-   Command 퍼블릭 인터페이스의 execute 메서드만으로 모든 객체들의 제어가 가능해진다.
-   커맨드 패턴을 사용하면 요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있다. 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수도 있다.
-   Null 객체 활용 가능: 딱히 리턴할 객체도 없고 클라이언트가 null을 처리하지 않게 하고 싶을 때 활용.

### 템플릿 메서드 패턴
- 알고리즘의 구조를 그대로 유지하면서 알고리즘의 특정 단계를 서브 클래스에서 재정의하여 사용할 수있다.
- 템플릿 메서드는 알고리즘의 각 단계를 정의하며, 서브 클래스에서 일부 단계를 구현할 수 있도록 유도한다.
- Hook 메서드 사용 가능: 추상클래스에서 기본적인 내용으로 메서드를 구현해놓고 서브클래스에서 필요할 때만 오버라이딩해서 사용가능
- 템플릿 메서드 패턴은 프레임워크를 만드는데 좋은 디자인 도구다. 프레임워크로 작업이 처리되는 방식을 제어하면서도 프레임워크에서 처리하는 알고리즘의 각 단계를 사용자가 마음대로 지정할 수 있다. 
- 실전 사용 예: JAVA의 정렬 템플릿 메서드를 사용하기 위해서는  정렬될 객체에서 Comparable 인터페이스의 compareTo() 메서드를 오버라이딩하여 구현해야만 정렬할 수 있다.
