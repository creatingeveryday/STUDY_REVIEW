


# 오브젝트
- 복잡함을 어떻게 다룰 것인가? 
- 객체지향 프로그램을 설계하고 유지보수하기 위한 책
- 코드를 직접 쓰면서 개념과 이론을 익혀보자. 
- 1주일에 한 챕터씩 읽고 정리하자. 
- 읽으면서 개발 프로세스에 대해서 다시 한번 생각해보게 되었다. 

### 1. 객체, 설계

- 패러다임 쉬프트: 절차지향패러다임과 공존, 객체지향 패러다임이란? 언제 적용하는게 적합할까?
- 제대로 동작하고, 변경하기 쉽고, 이해하기 좋은 모듈을 만드려면?  
	- 변경하기 쉽다? 
		- 객체간 의존성을 최소한으로 유지할 것!
		- 변경되는 부분은 어떤 부분인가? 어떻게 관리해야하는가?
		- 결합도가 낮아야 한다. 
		- 응집도가 높아야 한다. 
	- 이해하기 좋다? 
		- 세부적인 내용을 한번에 기억해야하는 코드를 작성하지말자. 
		- 상식적으로 작성해야 이해하기 쉽다. 
	- 자율적인 존재, 캡슐화, 메시지로 의사소통, 책임(기능)의 분산
	- 자신의 데이터를 스스로 처리하는 자율적인 객체? 
	- 적절한 지점? 
	- 객체 지향적으로 모듈을 만들어야 변경에 용이하고 상식적으로 이해하기 좋다. 
	- => 결국 나의 시간과 같이 일하는 사람, 모두의 시간을 절약할 수 있는 모듈을 만드는게 핵심인 것 같다.
		- 내가 만든 모듈은 변경하기 쉽고 이해하기 좋은 모듈일까??? 이 책을 읽으면서 정말 그런가 생각해보게 됬다. 조금 더 고치면 더 좋은 모듈이 될 수 있지 않을까? 이 책을 읽으면서 조금씩 적용해봐야겠다. 
	- 특히나 이해하기 쉽게 코드를 작성하는 것은 실무에서 매우 중요하다.
	- 어떠한 기능을 설계하는 방법은 여러가지. 모두를 만족하는 설계는 존재하지 않는다. 
	- 설계는 균형의 예술.
	- 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다. 
	- 요구사항은 무조건 변화한다. 

### 2. 객체지향 프로그래밍 

- 객체 지향은 객체를 지향하는 것이다. 
- 클래스가 아닌 객체에 집중해야한다.
	- 어떤 클래스가 필요한지 고민하기전에 먼저 어떤 객체가 필요한지 고민하자.
	- 객체는 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원이다.
- 어떤 문제를 해결하는가? 
- 객체지향 패러다임이 강력한 이유는? 
	- 요구사항과 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있다.
	- 연결된다는 의미는?
	- 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있다.
- 실제로 코딩을 하기 전에 도메인구조와 그와 유사하게 클래스 구조를 미리 만들어야겠다. 
	- 클래스 내부와 외부의 경계를 분명히 정해야한다. -> 객체의 자율성 보장, 구현의 자유
	- 상태와 행동을 가진 자율적인 존재로 객체를 디자인해야한다. (데이터와 기능을 묶어서 캡슐화)
	- 어떤 객체가 어떻게 협력을 할 것인지 미리 생각해보자.
	- 도메인구조랑 클래스 구조를 미리 그릴때 어떤 점을 미리 생각해봐야될까?? 
		- 문제를 해결하기 위해 어떤 객체가 필요한가? 어떤 데이터를 저장하고 어떤 동작이 필요하지? 
		- 문제를 해결하기 위해 생성한 객체를 어떻게 협력하게 할까? 어떤 방식이 효율적인지 알기 위해서는  많은 경험이 필요할까?
		- 미래에 발생할 문제를 해결하기 위해 처음보는 사람도 쉽게 이해하기 쉬운 구조로 만들어야겠다. 
		- 문제를 해결하기 위해 만든 모듈을 그림으로 표현하기가 쉬운가? 이해하기도 쉬운가?
		- 인터페이스와 같은 추상적인 요소에 초점을 우선 맞추자. 
		- 
- 프로그래머의 역할을 언어, 프레임워크를 만드는 사람과 그렇게 만들어진 도구로 애플리케이션을 구축하는 사람으로 나눌 수 있다.
- 설계가 필요한 이유는 변경을 관리하기 위해서이다.  
- 내가 작성한 코드가 의미를 잘 전달할 수 있는지 확인...
- 메시지와 메서드를 구분하라
- 트레이드 오프 
	- 유연성과 가독성: 설계가 유연해질 수록 코드를 이해하고 디버깅하기 어려워진다. 유연성을 억제하면 코드를 이해하고 디버깅하기 쉬워지지만 재사용성과 확장가능성은 낮아진다.
- 상속 : 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 인터페이스 상속을 사용해야 변경에 유연한 코드를 작성할 수 있다.
- 다형성: 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다. 
- 추상화: 추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다. 
- 유연성이 필요한 곳에는 추상화를 사용하자. 
- 상속? 합성? 
	- 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법. 인터페이스에 정의된 메시지를 통해서만 코드를 재사용, 내부 구현에 대해 불필요한 부분을 알 필요는 없다.
	- 상속은 캡슐화를 위반하고 유연하지 못한 설계 방법이다.  클래스를 통해 강하게 결합되는 형태.
	- 상황을 살펴보고 적합한 방법을 선택해야한다. 
- 
### 3. 역할, 책임, 협력
- 객체지향 패러다임의 관점에서 객체지향 프로그래밍의 핵심은 역할, 책임, 협력이다. 
	- 협력: 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용
	- 책임: 객체가 협력에 참여하기 위해 수행하는 로직
	- 역할: 객체들이 협력안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다. 
- 어떻게 협력하는 객체의 공동체를 창조할 것인가? 
	- 객체 지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다. 
	- 클래스와 상속은 객체들의 책임과 협력이 어느 정도 자리를 잡은 후에 사용할 수 있는 구현 메커니즘일 뿐이다.
	- 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현에 초점을 맞추는 것은 변경화기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.
	- 자율적인 객체를 기본적으로 만드는 방법은 캡슐화. 변경의 전파를 제한해 변경하기 쉬워진다.
- 협력
	- 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다. 
	- 상태는 객체가 행동하는 데 필요한 정보에 의해 결정된다.
	- 행동은 협력 안에서 객체가 처리할 메시지로 결정된다. 
	- 협력은 객체를 설계하는데 필요한 일종의 문맥을 제공한다고 볼 수 있다. 
- 책임 
	- 협력에 참여하기 위해 객체가 수행하는 행동
	- 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다
	- 후보-책임-협력자(CRC) 카드와 같은 실재적이고 구체적인 툴을 활용하여 역할을 식별하고 책임을 할당하고 책임을 명시적으로 표현할 수 있다.  
	- 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보자. 
	- 책임 주도 설계
		- 시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다.
		- 시스템 책임을 더 작은 책임으로 분할한다. 
		- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다. 
		- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다. 
		- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. 
	- 메시지가 객체를 결정한다.
		- 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 결정한다. 
		- 그래야만 충분히 추상적이고 최소한의 인터페이스를 설정할 수 있다. 
	- 객체를 객체답게 만드는 것은 객체의 상태가 아니라 객체가 다른 객체에게 제공하는 행동이다. 
		- 객체의 내부구현에 초점을 맞추는 데이터 주도 설계는 캡슐화를 저해하고 의존하는 객체에게 변경이 전파된다. 
		- 상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일 뿐이다. 상태는 행동을 결정한 후에 결정해야 한다. 
		- 협력이라는 문맥 안에서 객체의 행동을 고민하자. 
- 역할 
	- 객체는 협력이라는 주어진 문맥 안에서 특정한 목적을 갖게 된다. 
	- 객체의 목적은 협력 안에서 객체가 맡게되는 책임의 집합으로 표시된다. 
	- 이처럼 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할이라고 부른다.
	- 협력 모델링시 역할에게 책임을 할당한다고 생각하는게 좋다. 
	- 역할은 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯이자 구체적인 객체들의 타입을 캡슐화하는 추상화
	- 협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용가능해진다는 것이다. 
	- 실전 팁
		- 현실적으로 도메인 모델 안에는 개념과 객체와 역할이 뒤섞여있다. 
		- 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야하고, 역할과 객체를명확하게 구분하는 것은 그렇게 중요하지 않다.
		- 단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할을 분리해내는 것이다
		- 중요한 것은 책임이다. 협력을 위해 어떤 책임이 필요한지 분명하게 이해해야한다. 

<3장 정리>
-  어떻게 협력하는 객체들의 공동체를 창조할 것인가?
    -   객체지향 프로그래밍의 핵심은 역할, 책임, 협력
    -   협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당한다.
    -   객체가 어떤 협력에 참여하고 있는지에 따라 객체의 행동(책임)을 결정하고, 객체의 행동에 따라 객체의 상태를  결정해야 한다.
-   그렇다면 어떻게 객체에게 적절한 책임이 할당되는가?
    -   우선  처리해야 할  메시지(요청)를 식별한다.
    -   요청을 처리할 책임을 수행하는데 필요한 정보를 가장 잘 아는 객체에게 메시지(요청)를 보낸다.
    -   메시지를 수신한 객체는 응답하기 위해 필요한 행동을 하게 되는데, 이 행동이 객체가 수행할 책임으로 이어진다.
    -   요청을 받은 객체는 요청에 응답하기 위해 필요한 행동(책임)을 수행한다. 이 과정에서 도움을 요청해서 처리해야할 메시지를 식별하고 다시 요청을 처리하는데 필요한 정보를 가장  잘 아는  객체에게 책임을 할당한다.
    -   이렇게 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이루어진다.

> 책임  할당 시  고려해야 할 2가지 요소  
> 1. 메시지가  객체를 결정한다.  
> 2. 행동이  상태를 결정한다. 협력이라는  문맥 아래에서  객체의 행동과 그 행동에 필요한 상태를  결정해야 한다.

-   배우라는 구체적인 객체에 책임을 할당하지 않고 배역이라는 역할 자체에 책임을 할당한다면?
    -   역할은 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯이자 구체적인 객체(배우)들의 타입을 캡슐화하는 추상화이다.  
    -   협력을 구체적인 객체(배우)가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고  재사용 가능해진다.
    -   추상 클래스와 인터페이스를 통해 역할을 구현할 수 있다.
    -   역할은 객체를 추상화해서 객체 자체가 아닌 협력에 초점을 맞출 수 있게 한다.

###  4. 설계 품질과 트레이드 오프
-	객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다. 
	-	설계는 변경을 위해 존재하고 변경에는 어떤 식으로든 비용이 발생한다. 휼륭한 설계란 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다.  객체의 행동에 초점을 맞추어 결합도와 응집도를 합리적인 수준으로 유지해야한다. 
	-	객체의 책임을 먼저 생각하라.

-	설계의 비교 기준
	-	캡슐화
		-	외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화
		-	변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개하여 변경의 여파를 통제하고 최소화하는가? 
		- 구현은 변경될 가능성이 높지만 인터페이스는 변경될 가능성이 낮다. 그래서 우리는 인터페이스를 공개해야한다.
		- 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화
		- 캡슐화하면 유지보수성이 향상되어 두려움 없이, 주저함 없이, 저항감 없이 코드를 변경할 수 있다.  	
		- 캡슐화의 정도가 응집도와 결합도를 결정한다. 
	-	응집도
		-	모듈에 포함된 내부 요소들이 연관돼 있는 정도
		-	모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 응집도가 높다고 말할 수 있다.
		-	객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는가? 
		-	변경이 발생할때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있으며, 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높고, 모듈의 일부가 변경된다면 응집도가 낮은 것이다. 
		-	응집도가 높을 수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다. 변경으로 인해 수정되는 부분을 파악하기 쉽고 여러 모듈을 수정할 필요 없이 오직 단 하나의 모듈만 수정하면된다. 
	-	결합도
		-	의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
		-	다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 결합도가 낮다고 말할 수 있다. 
		-	객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는가?
		-	한 모듈이 변경되기 위해서 다른 모듈의 변경을 얼마나 요구하는가? 
		-	낮은 결합도를 가지고 있다면 오직 하나의 모듈만 변경하면되지만, 높은 결합도를 가지고 있다면 다수의 모듈을 동시에 변경하기 때문에 낮은 결합도를 가져야 변경에 유리하다고 볼 수 있다.
		-	내부 구현이 변경될때 이것이 다른 모듈에 영향을 미치는 경우 결합도가 높다고 볼 수 있다.
		-	퍼블릭 인터페이스가 변경될때만 다른 모듈에 영향을 미치는 경우에는 결합도가 낮다고 볼 수 있다.  
	-	좋은 설계는 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다.
		-	높은 응집도와 낮은 결합도를 추구해야 좋은 설계를 만들 수 있다. 
		-	결국 응집도와 결합도는 변경과 관련된 것이다. 

-	좋은 설계와 나쁜 설계 비교해보기 
	- 데이터 중심 VS 책임 중심
	- 상태를 객체 분할의 중심축으로 생각하기 VS 책임을 객체 분할의 중심축으로 생각하기
	- 데이터 중심
		- 어떤 데이터를 객체 내부에 저장해야되는가? 
		- 데이터 중심의 관점에서 객체는 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의한다. 
		- 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할한다.
		- 객체의 상태에 초점을 맞춘다. 
		- 객체는 독립된 데이터 덩어리일뿐이다. 
		- 변경에 취약하다. 
		- 객체의 상태는 구현에 속하고 구현은 변하기 쉽다. 구현에 관한 세부 사항이 객체의 인터페이스에 영향을 주어 캡슐화의 원칙이 무너진다. 상태변경은 인터페이스의 변경을 초래하며 인터페이스에 의존하는 모든 객체에게 영향이 전파된다.
		- 데이터 중심 설계는 캡슐화를 위반하기 쉽다. 그러므로 결합도가 높고 응집도가 낮은 객체들을 양산하게될 가능성이 높다. 
		
	- 책임 중심
		- 책임 중심 관점에서 객체는 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관한다.
		-  객체의 행동에 초점을 맞춘다. 
		- 객체는 협력하는 공동체의 일원이다.
		- 상대적으로 변경에 안정적인 설계를 얻을 수 있다. 
		- 객체의 책임은 인터페이스에 속하므로 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다. 

- 데이터 중심 설계의 문제점
	- 캡슐화 위반
		- ***getter 와 setter 메서드를 사용했다고 캡슐화 원칙을 지키고 있다고 말할 수 있는가?***
			- 아니다. 그 메서드로 객체내부의 특정 변수가 존재한다고 퍼블릭 인터페이스에 노골적으로 드러낸다.
			- 캡슐화의 원칙을 어긴 근본적인 원인은 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 마주었기 때문이다. 중요한 것은 책임이며 구현을 캡슐화할 수 있는 적절한 책임은 협력이라는 문맥을 고려할 때만 얻을 수 있다. 
			-  접근자와 수정자에 과도하게 의존하는 설계 방식은 추측에 의한 설계 전략이라고 부른다. 객체가 어떤 협력에 참여할지 고려하지않고 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행하기 때문이다. 
			- 대부분의 내부 구현이 퍼블릭 인터페이스에 그대로 노출되며 변경에 매우 취약해진다.
		
			
	- 높은 결합도
		- 객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미한다.
		- 객체 내부의 구현을 변경하더라도 인터페이스 의존 하는 모든 클라이언트도 변경해야한다. 
		- 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체안에 집중되기 때문에 제어 객체를 함께 변경할 수 밖에 없는 상황이 발생한다. 
		- 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어버린다. 변경은 시스템 전체로 전파된다. 
		
		
	- 낮은 응집도
		- 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 할 수 있다. 
		- 하나의 요구사항을 변경하기 위해 동시에 여러 모듈을 수정해야 한다. 
		- 변경시 변경과 상관 없는 코드도 영향을 받는다. 

- 어떻게 개선할 것인가?
	- 캡슐화 원칙을 지킨다. 
		- 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야한다. 
			- 메서드는 단순히 속성에 대한 getter나 setter를 의미하지 않는다. 
			- 의미있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드다. 
			- getter 나 setter는 내부 구현을 인터페이스의 일부로 만들어 캡슐화를 위반한다.  
			-  getter 나 setter로 외부에서 객체를 하나씩 조작하지 말고 객체 스스로 자신의 상태를 관리하게 만들어서 캡슐화를 강화시킨다.
			
	- 객체 스스로 자신의 데이터를 책임지게 한다. 
		- 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다. 
		- 객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다. 
	- 그래도 한계점은 존재한다. 
		- 캡슐화 위반
			- 내부 구현의 변경이 외부로 퍼져나가는 파급효과가 여전히 발생한다면 캡슐화 실패로 봐야한다.
			- 캡슐화는 변경될 수 있는 모든 것을 감추는 것을 의미한다. 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화해야한다.  
			- 캡슐화를 위반하면 높은 결합도와 낮은 응집도라는 결과를 불러온다. 
		- 왜 이런 문제점이 발생하는가? 
			- 데이터 중심 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
				- 객체의 행동보다 상태에 초점을 맞춘다. 
			- 데이터 중심 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

- 더 생각해볼 부분
	- 메시지를 발견하고 책임을 할당했다면 그 이후에 어떻게 응집도와 결합도가 높게 구현해나가는가?  
	- 어떻게 내부 구현 변경이 외부로 전파되는 것을 차단할까? 
	- 기존 모듈이 캡슐화 원칙이 위반된 경우 어떻게 대처해야할까? 
			 
### 5. 책임 할당하기
- 왜 책임에 초점을 맞춰야하는가? 
	- 데이터 중심 설계는 행동보다 데이터를 먼저 결정하고 협력이라는 문맥을 벗어나 고립된 상태의 객체에 초점을 맞추기 때문에 캡슐화를 위반하기 쉽고, 결합도가 높아지고, 응집도가 낮아지며, 코드를 변경하기 어려워진다. 
	- 이러한 문제점을 해결할 수 있는 가장 기본적인 방법은 책임에 초점을 맞추는 것이다.
	- 그런데 어떤 객체에게 어떤 책임을 할당할지 결정하는 것이 쉽지 않다. 
	- 동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라진다. 
	- 그러므로 다양한 관점에서 설계를 평가해야만 올바르게 책임을 할당할 수 있다. 

- 어떻게 책임 할당의 어려움을 해결할 것인가? 우선 기본적인 원칙을 지켜야한다. 
	- 데이터가 아니라 객체의 책임과 협력에 초점을 맞추어라. 
		- 데이터 보다 행동을 먼저 결정하라.
			- 협력에 참여하기 위해 어떤 행동이 필요한가? 를 먼저 묻고 그 행동에 필요한 데이터를 결정해야한다는 것이다. 
			- 어떤 행동이 필요한지 알기 위해서는 먼저 어떤 상황인지 협력이라는 문맥을 파악해야한다.  
		- 협력이라는 문맥 안에서 책임을 결정하라. 
			- 객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정된다. 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야한다. 
			- 협력을 시작하는 주체는 메시지 전송자이므로 메시지 전송자에 적합한 책임이 협력에 적합한 책임이다. 
			- 메세지를 결정한 후에 객체를 선택해야한다. 메시지가 존재하기 때문에 그 메시지를 처리할 객체가 필요한 것이다. 
			- 클라이언트는 단지 임의의 객체가 메시지를 수신할 것이라는 사실을 믿고 자신의 의도를 표현한 메시지를 전송할 뿐이다. 그리고 메시지를 수신하기로 결정된 객체는 메시지를 처리할 책임을 할당받게 된다.
			- 메시지 송신자는 메시지 수신자를 모르기 때문에 캡슐화가 잘 지켜진다. 
			
	- 책임할당을 위한 GRASP 패턴 (General Responsibility Assignment Software Pattern)
		- 설계를 시작하기 전 도메인에 대한 개략적인 모습을 그려보자. 
			- 도메인 개념을 책임 할당의 대상으로 사용하면 코드에 도메인을 투영하기가 좀 더 수월해진다.
			- 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다. 
			- 올바른 도메인 모델이라는 정답은 없다. 올바른 구현을 이끌어 낼수 있다면 충분하다. 실용적으로 접근하자.
			- 실제로 코드로 구현해나가면서 유연성이나 재사용성을 위해서 도메인 모델을 역으로 바꾸기도 한다. 
			
		- Information Pattern: 정보 전문가에게 책임을 할당하라. 
			- 애플리케이션이 제공해야 하는 기능을 책임으로 생각해야한다.
			- 책임은 전송된 메시지(요청)이며 애플리케이션은 이 책임을 수행해야할 의무가 있다.
			- 이제 이 책임을 수행하는데 필요한 메시지를 결정해야한다. ex) 예매하라! 
			- 메시지를 결정했다면 메시지를 수신할 적합한 객체를 선택해야한다. 
				- 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하자. 
				- 정보를 알고 있다는 것은 저장하고 있다는 것과 다르다.
				- 해당 정보를 제공할 수 있는 다른 객체를 알고 있으면 휼륭하게 책임을 수행할 수 있다.
			- 메시지를 수신할 객체가 정해졌다면 해당 객체가 책임을 수행하는데 필요한 작업을 구상해보고 스스로 처리할 수 없는 작업이 무엇인지 가려내야한다.
			- 스스로 처리할 수 없는 작업은 외부에 도움을 요청해야하며 이 도움 요청이 외부로 전송해야하는 새로운 메시지가 된다. 
		- Low Coupling Pattern: 낮은 결합도를 유지하도록 책임을 할당하라.
			- 의존성을 낮추고 변화의 영향을 줄이면서 재사용성을 증가시킬 수 있다.
		- High Cohesion Pattern: 높은 응집도를 유지하도록 책임을 할당하라.
			- 서로 다른 이유로 변경되는 책임을 짊어지게 되면 응집도가 낮아지고 변경하기 어렵게 된다. 
		- Creator Pattern: 창조자에게 객체 생성 책임을 할당하라. 
			- 객체 A를 생성할 때 어떤 객체에게 객체 생성 책임을 할당해야하는가? 아래의 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라. 
				- B가 A 객체를 포함하거나 참조한다.
				- B가 A 객체를 기록한다.
				- B가 A 객체를 긴밀하게 사용한다.
				- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. ( B는 A에 대한 정보 전문가)
			- 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.
			- 이미 결합되어있기 때문에 책임을 할당하더라도 설계 전체의 결합도에 영향을 미치지 않는다. 
		
		- 이렇게 대략적으로 구상을 해보았다면 이제 실제로 협력과 책임이 제대로 동작하는지 코드를 작성하면서 확인해야한다.
			- 메시지의 시그니처는 메시지 송신객체의 의도를 표현하게 만든다.
			- 메시지가 객체간의 유일한 연결고리가 되면 캡슐화 원칙을 잘 지킬 수 있다. 
			
			- 낮은 응집도의 모듈은 변경의 이유에 따라 클래스를 분리해야한다.
				- 변경의 이유가 하나 이상인 클래스는 낮은 응집도를 가지기 때문이다.
				- 응집도가 낮은 모듈을 어떻게 찾을 수 있을까? 
					- 클래스의 인스턴스 변수를 초기화 할때 모든 속성이 초기화 되지 않고 일부 속성만 초기화된다면? 
						- 함께 초기화 되는 속성을 기준으로 코드를 분리해야한다.
					- 메서드가 인스턴스 변수를 모두 사용하지 않고 일부만 사용한다면?
						-  해당 인스턴스 속성과 메서드 그룹을 기준으로 코드를 분리해야한다. 
			- Polymorphism Pattern: 인터페이스를 활용해 분리한 클래스를 동일한 역할을 수행하게 한다. 
				- 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하는 것이다.
				- 조건 논리는 변경에 취약하다. 
				
			-  Protected Variations Pattern: 변경을 캡슐화하도록 책임을 할당하라. 
				- 객체지향 설계를 할 때 도메인에 대한 이해가 필수적으로 요구되는 이유는? 
				- 캡슐화하기 위해서는 변경될 부분을 미리 식별할 수 있어야 한다. 
				- 도메인의 구조가 코드의 구조를 이끈다.
				- 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라.
				
			- 설계시 변경에 대처하는 2가지 방법
				- 1 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것이다.
				- 2 다른 하나는 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것이다.
				- 대부분의 경우 최대한 단순하게 설계하는 방법이 좋지만 변경이 반복적으로 발생하는 경우 복잡성이 조금 상승하더라도 유연성을 추가하는 2번째 방법이 더좋다고 한다. 번거로움과 실수를 줄여주어 오류를 줄일 수 있다. 
			- 코드의 구조가 도메인의 구조에 대한 새로운 통찰력을 제공한다.
				- 실제로 코드를 작성하던 중  도메인의 요구사항을 수용하기 위해 코드의 구조를 수정한다면? 
				- 도메인 모델 역시 코드의 관점에 따라 바뀌어야 한다.
				- 수정된 도메인 모델은 도메인에 포함된 개념과 관계뿐만 아니라 도메인이 요구하는 유연성도 정확하게 반영한다. 
				- 도메인 모델은 구현과 밀접한 관계를 맺고 있다.
				- 도메인 모델은 코드에 대한 가이드를 제공할 수 있어야 하며 코드의 변화에 발맞춰 함께 변화해야한다. 
				- 도메인 모델은 코드와 분리되어 있지 않다.
				
			- Refactoring : 이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것이다.  
				- 사실 책임 할당은 쉽지 않은 문제다. 도메인에 대한 이해가 필수적으로 요구되고 책임 할당도 난해하고 어렵다. 
				- 그래서 대부분 객체지향 언어로 절차형 프로그램을 작성하기 쉽다. 
				- 하나의 해결 방법으로 먼저 절차형 프로그램을 작성후에 객체지향적인 코드로 변경하는 리팩터링이라고 부르는 차선책이 존재한다. 
				- 기존 동작은 유지하되 내부 구조를 유연하게(높은 응집도, 낮은 결합도) 변경할 수 있다. 
				- 여러가지 일을 처리하는 긴 메서드를 분해하여 응집도를 높이자. 
					- 클래스가 작고,  목적이 명확한 메서드들로 구성돼 있다면 변경을 처리하기 위해 어떤 메서드를 수정해야 하는지를 쉽게 판단할 수 있다. 
					- 메서드의 크기가 작고 목적이 분명하기 때문에 재사용도 쉬워진다.
					- 작은 메서드들로 조합된 메서드는 마치 주석들을 나열한 것처럼 보이기 때문에 코드를 이해하기도 쉽다. 
					- 한 눈에 알아볼 수 있게 만들면 좋다.
					- 동시에 너무 많은 세부사항을 기억하도록 강요하는 코드는 이해하기 어렵기 때문이다. 메서드의 세부구현은 필요시 확인할 수 있게 메서드를 쪼개어 구현한다. 
					- 작고, 명확하고, 한 가지 일에 집중하는 응집도 높은 메서드는 변경 가능한 설계를 이끌어 내는 기반이 된다. 
				- 분해한 메서드는 각 메서드가 사용하는 데이터를 정의하는 클래스로 이동한다. 
					- 응집도가 높아지고 내부 구현을 확실하게 캡슐화할 수 있다. 
					- 불필요하게 내부구현을 노출시키는 모든  setter, getter 메서드를 제거할 수 있다. 

=> 실제로 처음부터 책임주도설계 과정 실습해보기
	
### 6. 메시지와 인터페이스

- 클래스라는 구현 도구에 지나치게 집착하면 경직되고 유연하지 못한 설계에 이를 확률이 높아진다.
- 객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고 받는 메시지다.
- 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다. 
- 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다.
- 훌륭한 퍼블릭 인터페이스를 얻기 위해서는 책임 주도 설계 방법을 따르는 것만으로는 부족하다. 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설계 원칙과 기법을 익히고 적용해야한다. 
- 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정한다. 객체의 퍼블릭인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 할 수 있다.

##### 협력과 메시지
- 메시지와 메시지 전송
	- 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다.
	- 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.  
	- 한 객체가 다른 객체에게 도움을 요청하는 것을 메시지 전송 또는 메시지 패싱이라고 부른다.
	- 메시지는 오퍼레이션명과 인자로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다. 
	- 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려있다. 
- 메시지와 메서드
	- 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다. 
	- 코드상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다. 
	- 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다. 
	- 즉, 메시지 전송을 코드 상에 표기하는 시점에서는 어떤 코드가 실행될 것인지를 정확하게 알 수 없다. 실행 시점에 실제로 실행되는 코드는 메시지를 수신하는 객체의 타입에 따라 달라지기 때문에 우리는 그저 메시지에 응답할 수 있는 객체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라고 믿을 수 밖에 없다.
	- 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다.
	- 메시지 전송자와 메시지 수신자는 서로에 대한 상세한 정보를 알지 못한 채 단지 메시지라는 얇은 끈을 통해 연결된다. 
- 퍼블릭 인터페이스와 오퍼레이션
	- 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다.
	- 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 한다. 
	- 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다. 
		- 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다. 
		- 흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다. 
	- 그에 비해 메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다.
	- 객체가 다른 객체에게 메시지를 전송하면 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다.
- 시그니처
	- 오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처(signature)라고 부른다. 
	- 오퍼레이션 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것이라고 정의할 수 있다.

##### 인터페이스와 설계 품질
- 좋은 인터페이스란? 
	- 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야한다.
	- 꼭 필요한 최소한의 오퍼레이션만을 인터페이스에 포함한다.
	- 어떻게가 아니라 무엇을 하는지를 추상적으로 표현하고 있어야한다.
	
- 디미터 법칙
	- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.  
	- 협력 경로를 제한하면 결합도를 효과적으로 낮출 수 있다. 
	- 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍해야한다. 
	- 다른 객체의 구현에 의존하지 않는 코드를 작성한다.
	- 클래스 내부의 메서드는 아래의 조건을 만족하는 인스턴스에게만 메시지를 전송해야한다고 봐도 무방하다.
		-  this 객체
		- 메서드의 매개변수
		- this의 속성
		- this의 속성인 컬렉션의 요소
		- 메서드 내에서 생성된 지역 객체
	- 디미터의 법칙을 따르면 메시지 전송자는 메시지 수신자의 내부 구조에 관해 묻지 않게 된다. 단지 자신이 원하는 것이 무엇인지를 명시하고 단순히 수행하도록 요청한다. 묻지 말고 시키는 메시지가 더 좋은 메시지다. 
	- 객체가 자기 자신을 책임지는 자율적인 존재이기에 가능하다. 
	- 하지만 무비판적으로 디미터 법칙을 수용하면 응집도가 낮아질 수도 있다. 

- 묻지말고 시켜라
	- 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다. 객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다. 
	- 내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재한다면 해당 객체가 책임져야하는 행동이 객체 외부로 누수된 것이다. 
	- 행동을 요청하는 오퍼레이션을 사용해라.
	- 인터페이스는 객체가 어떻게 하는지가 아니라 무엇을 하는지를 서술해야한다. 

- 의도를 드러내는 인터페이스
	- 어떻게 메서드 이름을 지어야하는가? 
		- 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름을 짓는 방식은 좋지 않다. 
			- 메서드의 이름은 내부 구현 방법을 드러낸다.
			- 동일한 작업을 수행하더라도 메서드명이 다르다.
			- 캡슐화 위반: 메서드가 클라이언트로 하여금 협력하는 객체의 종류를 알도록 강요한다. 
			- 책임을 수행하는 방법을 드러내는 메서드를 사용한 설계는 변경에 취약하다. 
		- 어떻게가 아니라 무엇을 하는지 드러내도록 이름을 지어야한다. 의도를 표현하라.
			- 먼저 객체가 협력안에서 수행해야하는 책임에 관해 고민해야한다. 
			- 이런 고민은 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만든다.
			- 결과적으로 협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게된다.
			- 객체에게 묻지말고 시키되 구현방법이 아닌 클라이언트의 의도를 드러내야한다. 

- 명령-쿼리 분리 원칙
	- 명령-쿼리 분리 원칙은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다. 
	- 루틴: 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈. 루틴은 다시 프로시저와 함수로 구분할 수 있다. 
	- 프로시저는 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류다. 
		- 부수효과를 발생시킬 수 있지만 값을 반환할 수는 없다. 
		- 객체의 인터페이스 측면에서 명령(Command)이라고 부른다. 
		- 객체의 상태를 수정하는 오퍼레이션을 의미한다.
	- 함수는 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류다. => 쿼리
		- 값을 반환할 수는 있지만 부수효과를 발생시킬 수 없다.
		- 객체의 인터페이스 측면에서 쿼리(Query)라고 부른다.
		- 객체와 관련된 정보를 반환하는 오퍼레이션을 의미한다.
	- 오퍼레이션은 명령이거나 쿼리 둘 중 하나여야만 한다. 명령인 동시에 쿼리가 되어서는안된다.
	- 명령과 쿼리를 분리해야하는 이유
		- 명령과 쿼리 역할을 동시에 수행하면 실행 결과를 예측하기 어렵다. 
		- 디버깅과 유지보수가 용이해진다.
		- 
	- 

##### 원칙의 함정
- 소프트웨어 설계에 법칙은 존재하지 않는다. 경우에 따라 다르다!
- 설계는 트레이드오프의 산물이므로 상황에 맞게 원칙을 적용해야 일관성있는 설계와 질서있는 코드를 작성할 수 있다.
- 원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것이다. 
- 디미터 법칙의 오해 
	- 디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부구조가 외부로 노출되는 경우로 한정된다. 
- 결합도와 응집도의 충돌
	- 일반적으로 어떤 객체의 상태를 물어본 후 반환된 상태를 기반으로 결정을 내리고 그 결정에 따라 객체의 상태를 변경하는 코드는 묻지말고 시켜라 스타일로 변경해야한다. 
	- 그러나 서로 상관 없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며 변경으로 쉽게 무너진다. 클래스는 하나의 변경 원인만을 가져야한다. 
	- 책임을 위임하여 캡슐화를 더 향상시키는 대신 각 클래스가 가진 본질적인 책임에 집중하여 응집도를 높이고 결합도를 낮추는 것이 더 좋은 방법일 수 있다. 
	
	#### 7. 객체 분해
	##### 어떻게 추상화를 할 것인가? 
	- 프로그래밍 언어는 좀 더 효과적인 추상화를 이용해 복잡성을 극복하려는 개발자들의 노력에서 출발
	- 프로시저 추상화 매커니즘
		- 소프트웨어가 무엇을 해야하는지를 추상화한다.
		- 정보를 조작
		- 기능 분해 및 알고리즘 분해라고 부른다.
	- 데이터 추상화 매커니즘
		- 소프트웨어가 무엇을 알아야 하는지 추상화한다. 
		- 데이터를 이용해 정보를 표현한다.
		- 데이터를 중심으로 타입을 추상화하는 추상데이터 타입 방식과 
		- 데이터를 중심으로 프로시저를 추상화하는 객체지향 방식으로 나눌 수 있다. 
	- 역할과 책임을 수행하는 객체가 객체지향 패러다임이 이용하는 추상화며, 기능을 협력하는 공동체를 구성하도록 객체들로 나누는 과정이 객체지향 패러다임에서의 분해를 의미한다.  
	- 프로그래밍 언어의 관점에서 객체지향이란 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용해 시스템을 분해하는 방법이다. 
	- 클래스라는 도구로 시스템을 분해.
	- 일반적으로 객체지향이 전통적인 기능 분해 방법에 비해 효과적이라고 말하는 이유가 무엇일까??
	
	##### 분해! 
	- 큰 문제를 인지 과부하의 부담 없이 단기 기억 안에서 한번에 처리할 수 있는 규모의 문제로 나누는 것.
	
	##### 프로시저 추상화와 기능 분해
	-  프로시저는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법이다.
	- 프로시저 중심의 기능 분해 관점에서 시스템은 입력 값을 계산해서 출력 값을 반환하는 수학의 함수와 동일하다. 시스템은 필요한 더 작은 작업으로 분해될 수 있는 하나의 커다란 메인 함수다.
	- 전통적인 기능 분해 방법은 하향식 접근법을 따른다. 분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될때까지 계속된다. 
	- 하향식 기능 분해의 문제점
		- 시스템은 하나의 메인 함수로 실제로 구성되어있는게 아니다.
		- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야한다.
		- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
		- 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
		- 데이터 형식이 변경될 경우 파급효과를 예측할 수 없다. 
		- 하향식은 새로운 것을 개발하고 설계하고 발견하는데 적합한 방법이 아니다. 

##### 모듈
- 시스템 변경을 하는 기본적인 전략은 변경되는 부분을 하나의 구현 단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것이다. 
- 기능을 기반으로 시스템을 분해하는게 아니라 경의 방향에 맞춰 시스템을 분해하는 것이다. 
- 기능 분해가 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정이라면 모듈분해는 감춰야하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정이다. 
- 모듈이 감춰야할 비밀
	- 복잡성: 모듈이 너무 복잡한 경우 이해하고 사용하기가 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 모듈의 복잡도를 낮춘다. 
	- 변경가능성: 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다. 변경 발생시 하나의 모듈만 수정하면 되도록 변경 가능한 설계 결정을 모듈 내부로 감추고 외부에는 쉽게 변경되지 않을 인터페이스를 제공한다.  


#### 8. 의존성 관리하기

- 잘 설계된 객체지향 애플리케이션은 작고 응집도 높은 객체들로 구성된다. 
- 작고 응집도 높은 객체란 책임의 초점이 명확하고 한 가지 일만 잘하는 객체를 의미한다. 
- 협력은 필수적이지만 과도한 협력은 설계를 곤경에 빠트릴 수 있다. 협력은 객체가 다른 객체에 대해 알 것을 강요한다. 협력으로 객체 사이의 의존성이 생긴다.
- 협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다. 
- 객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는데 있다.  
- 이런 관점에서 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술이라고 할 수 있다. 

#####  의존성 
- 의존성은 실행시점과 구현 시점에 서로 다른 의미를 가진다. 
- 두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다. 
- 의존성은 변경에 의한 영향의 전파 가능성을 암시한다. 
- 변경의 방향과 캡슐화의 정도에 따라 의존성 전이가 발생할 수도 있다. 
- 런타임 의존성과 컴파일타임 의존성이 다를 수 있다.
	- 런타임 의존성: 실행 시점의 의존성을 의미.
	- 컴파일타임 의존성: 코드 그 자체가 가지는 의존성, 코드를 작성하는 시점을 의미
	- 유연하고 재사용가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야한다. 
	- 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들수 있어야한다는 의미이다.

##### 컨텍스트 독립성
- 클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다. 
- 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 
- 이를 컨텍스트 독립성이라고 부른다. 
- 컨텍스트 독립적이어야 시스템을 변경하기 쉽다. 

##### 의존성을 어떻게 해결할 것인가? 
- 의존성 해결이란? 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의미한다. 
- 어떻게 컴파일타임 의존성을 런타임 의존성으로 대체할 것인가? 
	- 객체를 생성하는 시점에 생성자를 통해 의존성 대체
	- 객체 생성 후  setter 메서드를 통해 의존성 대체
	- 메서드 실행 시 인자를 이용해 의존성 해결
		- 메서드가 실행될 때마다 의존 대상이 매번 달라져야하는 경우 유용하다.
		- 그러나 매번 동일한 객체를 인자로 전달하고 있다면 생성자, setter를 이용해 의존성을 지속적으로 유지하는 방식으로 변경하는 것도 좋다. 
	
##### 유연한 설계 
- 의존성과 결합도
	- 의존성의 정도를 바람직하게 조절 
	- 바람직한 의존성이란? 클래스 재사용을 제한하지 않고 다양한 환경에서 의존성을 재사용할 수 있다.
	- 다른 환경에서 재사용하기 위해 내부 구현을 변경하게 만드는 모든 의존성은 바람직하지 않은 의존성이다.  
	- 결합도가 약해야 바람직하다.
	- 결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.
	- 추상화에 의존하라.
		- 클래스  내부에서 구체 클래스에 대한 모든 의존성 제거
		- 명시적으로 의존성을 표현하여 의존성을 파악하기 위해 내부 구현을 살피지 않게 하라.
		-  퍼블릭 인터페이스로 명시적으로 의존성을 표현하자. 
		- 의존성이 명시적이지 않으면 클래스를 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야한다는 것이다. 
	- new 연산자는 해롭다. 잘못 사용할 경우 결합도가 매우 높아진다. 
	- 생성자 체이닝 활용
	- 설계는 트레이드 오프 활동. 결합도와 사용성을 고려하라. 
- 어떤 객체와 협력하느냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용 가능한 설계가 가진 특징이다.
	- 유연하고 재사용가능한 설계는 응집도 높은 책임들을 가진 작은 객체들을 다양한 방식으로 연결함으로써 애플리케이션의 기능을 쉽게 확장할 수 있다. 
	- 좋은 코드는 클래스의 인스턴스를 생성하는 코드를 보는 것만으로 객체가 어떤 일을 하는지를 쉽게 파악할 수 있다. 
	- 유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합합으로써 새로운 행동을 이끌어낼 수 있는 설계다. 
	- 핵심은 의존성 관리다. 


#### 9. 유연한 설계
- 개방-페쇄 원칙 (OCP)
	- 소프트웨어 개체(클래스,모듈,함수 등)는 확장에 대해 열려있어야 하고, 수정에 대해서는 닫혀있어야 한다.
	- 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 애플리케이션의 기능을 확장할 수 있는가? 
	- 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있는가? 
	- 어떻게 코드를 수정하지 않고 새로운 동작을 추가할 수 있지? 
	- 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하면 된다. 
	- OCP 원칙을 수용하는 코드는 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경할 수 있다. 
	- OCP 원칙의 핵심은 추상화에 의존하는 것이다. 
		- OCP 원칙의 관점에서 생략되지 않고 남겨지는 부분은 다양한 상황에서의 공통점을 반영한 추상화의 결과물이다. 
		- 공통적인 부분은 문맥이 바뀌더라도 변하지 않아야 한다. 추상화 부분은 수정에 대해 닫혀 있다. 
		- 추상화를 통해 생략된 부분은 확장의 여지를 남긴다고 볼 수 있다. 
		- 의존성의 방향도 중요하다. 수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야한다. 
		- 단순히 추상화를 했다고 모든 수정에 대해 설계가 폐쇄되는 것은 아니다. 
		- 변경에 의한 파급효과를 최대한 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야만 한다. 
		- 추상화가 수정에 대해 닫혀있을 수 있는 이유는 변경되지 않을 부분을 신중하게 결정하고 올바른 추상화를 주의 깊게 선택했기 때문이라는 사실을 기억해야한다. 
- 생성 사용 분리
	- 객체 생성에 대한 지식은 과도한 결합도를 초래하는 경향이 있다. 
	- 객체를 어디서 생성할 것인가? 잘못된 위치에서 생성할 경우 결합도가 높아진다. 
	- 객체의 생성과 사용을 분리하자. 
	- FACTORY 객체 활용
		- 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체인 FACTORY를 활용한다.
		- FACTORY 객체는 도메인 모델에 속하지 않는다. 
		- 전체적으로 결합도를 낮추고 재사용성을 높이기 위해 도메인 개념에 할당돼 있던 객체 생성 책임을 도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동시킨 것이다. 
		- 도메인 모델은 단지 설계를 위한 출발점일 뿐이다. 
		- 종종 도메인 개념을 표현하는 객체에게 책임을 할당하는 것만으로는 부족한 경우가 발생한다. 
		- 실제로 동작하는 애플리케이션은 도메인 개념들을 초월하는 기계적인 개념들을 필요로 할 수 있다.
		- 어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면 도메인과 무관한 인공적인 객체를 추가하고 이 객체에게 책임을 할당하라. 
		- 객체지향 애플리케이션은 이처럼 도메인 개념뿐만 아니라 설계자들이 임의적으로 창조한 인공적인 추상화들을 포함하고 있다.
	
- 의존성 주입
	- 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 의존성 주입이라고 부른다. 
	- 생성자 주입
	- setter 주입
		- 단점: 객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지를 명시적으로 표현할 수 없다. 
	- 메서드 주입
	- 숨겨진 의존성이 나쁜 이유
		- 숨겨진 의존성은 코드를 읽기 어렵게 한다. 내부 구현을 이해할 것을 강요한다. 
		- 이해하기 어렵고 디버깅이 어렵다.
		- 단위테스트 작성도 어렵다.
		- 퍼블릭 인터페이스로 의존성에 대한 정보를 명확히 명시해야한다. 
		- 클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관점에서 휼륭한 코드다.
		- 클래스의 사용법을 익히기 위해 구현 내부를 샅샅이 뒤져야 한다면 그 클래스의 캡슐화는 무너진 것이다. 
		- 숨겨진 의존성은 의존성의 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어트려 놓는다. 그래서 디버깅하고 이해하기 어렵게 만든다. 
		- 깊은 호출 계층에 걸쳐 동일한 객체를 반복해서 전달해야할 경우에만 전역 매커니즘을 활용하는 게 좋다.
		 
 - 의존성 역전 원칙(DIP)
	 - 하나, 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
	 - 둘, 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.
	 - 셋, 의존성 역전은 의존성의 방향뿐만이 아니라 인터페이스의 소유권에도 적용된다. 추상화가 제공하는 인터페이스의 소유권 역시 역전시켜야한다. 클라이언트에게 인터페이스의 소유권을 위치시키자. 
	 - 왜???
	 - 협력에서 중요한 정책이나 의사결정, 비즈니스의 본질을 담고 있는 것은 상위 수준의 클래스이다. 
	 - 그런데 상위 수준의 클래스가 하위 수준의 클래스에 의존한다면 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게 될 것이다.
	 - 하위 수준의 변경 때문에 상위 수준의 클래스가 변경되면 안된다. 
	 - 상위 수준의 클래스는 하위수준에 의존하지 않아야 변경이 전파되지 않는다.
	 - 상위 수준의 클래스가 하위 수준의 클래스에 의존하면 재사용도 어렵다. 
	 - 추상화에 의존한다면 다양한 컨텍스트에서 재사용이 가능하다. 
	 - 훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜라.
	  
 - 유연한 설계는 유연성이 필요할 때만 옳다. 
	 - 항상 유연하고 재사용 가능한 설계만이 옳은 것은 아니다. 유연한 설계는 복잡성을 수반하기 때문이다. 
	 - 단순하고 명확한 설계는 유연성이 떨어질 수 있고 재사용하기 어려울 수 있다. 
	 - 미래에 변경이 일어날지도 모른다는 막연한 불안감은 불필요하게 복잡한 설계를 낳는다. 
	 - 단순하고 명확한 해법이 그런대로 만족스럽다면 유연성을 제거하고 단순하게 설계하는 것도 방법이다. 
 
 - 설계를 유연하게 만들기 위해서는 협력과 책임이 중요하다.
	 - 협력에 참여하는 객체가 다른 객체에게 어떤 메시지를 전송하는가? 
	 - 다양한 컨텍스트에서 협력을 재사용할 필요가 있는가? 없다면 설계를 유연하게 만들 필요가 없다. 
	 - 객체의 역할과 책임이 자리를 잡기전에 객체 생성 매커니즘을 성급히 결정하는 것을 주의해라. 
	 - 중요한 비즈니스 로직을 처리하기 위해 책임을 할당하고 협력의 균형을 맞추는 것이 객체 생성에 관한 책임을 할당하는 것보다 우선이다. 
	 - 역할, 책임, 협력의 모습이 선명하게 그려지기 전에 성급하게 의존성 관리를 하거나 객체 생성 매커니즘에 대해 고민하는 것은 위험할 수 있다. 

### 10. 상속과 코드 재사용 
- 상속
	- 재사용 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현기법이다. 
	- 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법인 '합성' 과 비교되는 방법이다.
	- 상속을 사용시 주의해야할 사항
		- 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아서 결합도를 낮춰야한다.
		- 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
		- 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다. 
		- 


- 중복된 코드를 제거하라: DRY 원칙 (Don't Repeat Yourself)
	- 요구사항이 변경됐을 때 두 코드를 함께 수정해야 한다면 이 코드는 중복이다.
	- 중복 코드는 수정과 테스트에 드는 비용을 증가시킨다.
	- 또 중복 코드는 변경을 방해한다.
	- 과연 중복 코드를 모두 찾아내서 수정했는지 장담할 수 있는가? 장담하려면 많은 확인이 필요하다. 
	- 중복이 여러군데에서 나타난다면 일일히 체크하는 것도 어려운 일이다. 실수하기 쉽다. 
	- 과연 그렇게 수정한 코드가 이전과 동일한 결과를 보장하는가? 테스트가 필요하다. 
	- DRY 원칙 (Don't Repeat Yourself)
		- 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다. 
		- 단일 지점 제어 원칙이라고도 불린다. 
	- 중복 코드는 새로운 중복코드를 생산하기 쉽다. 
	- 새로운 중복 코드를 추가하는 과정에서 코드의 일관성이 무너질 위험이 있다. 
	- 민첩하게 요구사항을 변경하기 위해서는 중복 코드를 제거해야한다. 
	- 기회가 생길때마다 코드를 DRY 하게 정리해라. 
- 상속으로 중복 코드를 효과적으로 다룰 수 있을까?
	- 상속으로 중복 코드를 효과적으로 다루기는 어렵다.
	- 상속을 염두에 두고 설계되지 않은 클래스에 적용하기 어렵다. 
	- 상속은 결합도를 높이고 슈퍼클래스와 서브 클래스가 강하게 결합되어 코드 수정을 어렵게 만든다. 
	- super 호출을 제거하라. 
- 상속의 문제점 
	- 취약한 기반 클래스 문제
		- 상속으로 연결된 서브 클래스가 슈퍼 클래스의 변경에 취약해지는 현상이 나타나기 쉽다. 
		- 이 문제는 상속을 사용한다면 피할 수 없는 문제다. 
		- 상속은 자식 클래스를 점진적으로 추가해서 기능을 확장하는 데는 용이하지만 높은 결합도로 인해 부모클래스를 점진적으로 개선하는 것은 어렵게 만든다. 최악의 경우에는 모든 자식 클래스를 동시에 수정하고 테스트 해야할 수도 있다. 
		- 상속은 서브클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다.

	- 불필요한 인터페이스 상속 문제
		- 인터페이스 설계는 제대로 쓰기엔 쉽게 엉터리로 쓰기엔 어렵게 만들어야 한다. 
		- 슈퍼 클래스에서 상속받은 메서드를 사용할 경우 서브 클래스의 규칙을 위반하는 경우가 생기는 상황을 만들면 안된다. 
		- 퍼블릭 인터페이스에 대한 고려 없이 단순히 코드 재사용을 위해 상속을 이용하는 것은 위험하다.
		- 객체 지향의 핵심은 객체들의 협력이다. 단순히 코드를 재사용하기 위해 불필요한 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안된다. 
		- ex) Vector 를 상속한 Stack 클래스
		- ex) HashTable 를 상속한 Properties 클래스

	- 메서드 오버라이딩의 오작용 문제
		- 서브클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다. 
		- 그래서 이러한 문제를 막기 위해서 상속을 사용시 내부 구현을 문서화하고 캡슐화를 희생해야하는 아이러니가 발생한다. 
		- 캡슐화를 원한다면 코드 재사용을 포기하거나 상속이외의 다른 방법을 사용해야한다.

	- 부모 클래스와 자식 클래스의 동시 수정 문제 
		- 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다. 
		- 자식 클래스가 부모 클래스의 메서드를 오버라이딩 하거나 불필요한 인터페이스를 상속받지 않더라도 부모클래스를 수정할때 자식 클래스도 수정해야할 수도 있다. 
		- 상속은 기본적으로 부모 클래스의 구현을 사용한다는 기본 전제를 따르기 때문에 자식 클래스가 부모 클래스의 내부에 대해 속속들이 알도록 강요한다. 변경이 전파된다. 
	
### 11. 합성과 유연한 설계

- 합성이란?
	- 상속은 is-a 관계, 합성은 has-a 관계라고 부른다. 
	- 합성에서 슈퍼클래스와 서브클래스 두 객체 사이의 의존성은 런타임에 해결된다.
	- 합성은 퍼블릭 인터페이스에 의존한다.
	- 합성은 상속보다 변경에 더 안정적인 코드를 만들 수 있다.
	- 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다.(상속은 슈퍼 클래스 안에 구현된 코드 자체를 재사용함)

- 상속을 합성으로 변경하기
	- 서브 클래스에 선언된 상속 관계를 제거하고, 슈퍼클래스의 인스턴스를 서브 클래스의 인스턴스 변수로 선언한다.
	- 10장에서 살펴본 상속이 초래하는 문제들을 해결할 수 있다.
	- 불필요한 인터페이스 상속 문제
		- 합성을 사용하게 되면 꼭 필요한 퍼블릭 인터페이스만을 사용할 수 있게된다.
	- 메서드 오버라이딩의 오작용 문제
		- 인터페이스를 사용하면 구현 결합도는 제거하면서 퍼블릭 인터페이스는 그대로 상속받을 수 있다. 
		- 포워딩 기법: 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결합없이 일부 작동 방식을 변경하고 싶은 경우에 사용할 수 있는 유용한 기법. 
	- 슈퍼 클래스와 서브 클래스의 동시 수정 문제
		- 합성으로 변경하더라도 동시에 함께 수정해야하는 문제는 해결되지 않는다.
		- 그러나 합성으로 변경하면 변경의 파급효과를 최대한 서브 클래스 내부로 캡슐화 할 수 있다.
	- 불필요한 클래스 증가 문제
		- 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
		- 상속으로 수 많은 요구사항의 조합을 효과적으로 다룰 수 있을까?
	- 중복 코드 문제
		- 단일 상속만 지원하는 언어에서는 상속으로 인해 오히려 중복 코드의 양이 늘어날 수 있다.   

- 믹스인 

### 12. 다형성

- 상속은 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서만 사용해야한다. 단순히 코드 재사용목적으로 사용하기에는 좋지 않다. 
- 12장에서는 상속의 관점에서 다형성이 구현되는 기술적인 매커니즘에 대해 살펴본다. 
- 다형성은 런타임에 메시지를 처리하기에 적합한 메서드를 동적으로 탐색하는 과정을 통해 구현된다.
- 상속은 이런 메서드를 찾기 위한 일종의 탐색 경로를 클래스 계층의 형태로 구현하기 위한 방법이다.
- 상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것이다.

#### 다형성 
- 다형성은 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력으로 정의할 수 있다. 
- 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법이라고 할 수 있다.
- 다형성의 종류
	- 매개변수 다형성 parametric
		- 제네릭 프로그래밍과 관련이 높다. 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식을 가리킨다.
		- 예: 임의의 타입 T는 실제 인스턴스를 생성하는 시점에 구체적인 타입으로 지정할 수 있다. 
	- 포함 다형성 inclusion(서브타입  subtype 다형성)
		- 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미한다.
		- 객체지향 프로그래밍에서 일반적으로 지칭하는 다형성이다.
		- 포함 다형성을 구현하는 가장 일반적인 방법은 상속을 이용하는 것이다.
		- 상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것이다.
		- 포함 다형성을 위해 상속을 사용하는 가장 큰 이유는 상속이 클래스들을 계층으로 쌓아올린 후 상황에 따라 적절한 메서드를 선택할 수 있는 메커니즘을 제공하기 때문이다. 
		- 객체가 메시지를 수신하면 객체지향 시스템은 메시지를 처리할 적절한 메서드를 상속 계층 안에서 탐색한다. 
		- 실행할 메서드를 선택하는 기준은 어떤 메시지를 수신했는지에 따라, 어떤 클래스의 인스턴스인지에 따라, 상속 계층이 어떻게 구성돼있는지에 따라 달라진다.
	- 오버로딩 다형성 overloading
		- 하나의 클래스안에서 동일한 이름의 메서드가 서로다른 타입의 파라미터를 받아서 활용
	- 강제 다형성 coercion
		- 언어가 지원하는 자동적인 타입변환이나 사용자가 직접 구현한 타입변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식을 가리킨다. 

#### 상속의 양면성
- 객체지향 패러다임의 근간을 이루는 아이디어는 데이터와 행동을 객체라고 불리는 하나의 실행단위 안으로 통합하는 것이다. 
- 상속의 목적은 코드 재사용이 아니다. 상속은 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다.
- 타입계층에 대한 고민 없이 코드를 재사용하기 위해 상속을 사용하면 이해하기 어렵고 유지보수하기 버거운 코드가 만들어질 확률이 높다. 
- 상속을 언제 사용해야하는가? 
	-  상속을 사용하면 새로운 기능을 빠르게 추가할 수 있다. 그런데 단지 코드 재사용목적으로 상속을 사용해야하는가? 
	- 어떻게 부모클래스에서 구현한 메서드를 자식 클래스의 인스턴스에서 수행할 수 있는것일까?
		- 런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색한다. 포인터를 따라 차례대로 훑어가면서 검색한다.
		- 객체의 경우 서로다른 상태를 저장할 수 있도록 각 인스턴스 별로 독립적인 메모리를 할당받아야 한다. 하지만 메서드의 경우에는 동일한 클래스의 인스턴스 끼리 공유가 가능하기 때문에 클래스는 한번만 메모리에 로드하고 각 인스턴스 별로 클래스를 가리키는 포인터를 갖게 하는 것이 경제적이다.
		- 자식 클래스는 자신의 부모 클래스를 가리키는 포인터를 가지고 있다.
		- 자바에서는 최상위 parent 포인터는 Object 클래스를 가리킨다.

#### 업캐스팅과 동적 바인딩
-  동일한 수신자에게 동일한 메시지를 전송하는 동일한 코드를 이용해 서로다른 메서드를 실행할 수 있다.  코드 안에서 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것은 업캐스팅과 동적 바인딩이라는 매커니즘이 작용하기 때문이다.
- 업캐스팅: 부모 클래스  타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다.
- 동적바인딩: 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다. 이것은 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문에 가능하다. 
- 업캐스팅
	- 객체지향 언어는 명시적으로 타입을 변환하지 않고도 부모 클래스 타입의 참조 변수에 자식 클래스의 인스턴스를 대입할 수 있게 허용한다.
	- 반대로 부모클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해서는 명시적인 타입 캐스팅이 필요하다. (다운 캐스팅)
	- 컴파일러의 관점에서 자식 클래스는 아무런 제약 없이 부모 클래스를 대체할 수 있기 때문에 부모 클래스와 협력하는 클라이언트는 다양한 자식 클래스의 인스턴스와도 협력하는 것이 가능하다.
- 동적 바인딩
	- 메시지를 수신했을 때 실행될 메서드가 런타임에 결정된다.
	
#### 어떻게 이렇게 여러 타입을 대상으로 코드가 동작할 수 있는가?

-   상속과 합성(위임)을 통해 타입 계층이 구조화되어있어야 한다.
-   업캐스팅과 동적 바인딩 메커니즘을 기반으로 동작한다.
    -   업캐스팅: 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능하다.
    -   동적 바인딩: 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다. 이것은 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행시점에 결정하기 때문에 가능하다.
-   self 참조변수(this): 처음에 메시지를 수신한 객체를 가리킨다. self 참조가 가리키는 클래스에서 시작해서 상속 계층의 역방향으로 메서드를 탐색한다.
-   super 참조변수(super): 부모클래스의 인스턴스 변수나 메서드에 접근하기 위해 사용할 수 있는 내부 변수. super 참조를 이용해서 메시지를 전송하면 부모클래스부터 메서드 탐색을 시작한다.


### 서브 클래싱과 서브 타이핑
- 상속은 타입계층을 구현하는 용도로 사용한다. 타입 계층안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다. 
- 상속으로 코드 재사용을 편하게 할 수 있지만 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 생산할 수 있다.
- 상속을 이용하여 객체의 행동을 기반으로 타입 계층을 구성해야한다. 
- 올바른 타입 계층을 구성하는 원칙은?
- 타입 계층이란?
- 상속을 이용해 타입 계층을 구현한다는 것이 무엇을 의미하는가?

#### 1. 타입
- 개념 관점의 타입
	- 우리가 인지하는 세상 사물의 종류를 의미한다. 우리가 인식하는 객체들에 적용하는 개념이나 아이디어를 가리켜 타입이라고 부른다.
	- 타입은 사물을 분류하는 틀로 사용된다.
	- 일반적으로 타입의 인스턴스를 객체라고 부른다. 
- 프로그래밍 언어 관점의 타입
	- 타입은 연속적인 비트에 의미와 제약을 부여하기 위해 사용된다. 
	- 타입 개념이 존재하지 않는 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙이 타입이다.
	- 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의하는 목적으로 사용된다. 
		- 자바의 경우 '+' 연산자는 원시형 숫자타입이나 문자열타입의 객체에서만 사용가능하게 제한. 
	- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공하는 목적으로 사용된다.
		- 자바의 경우 '+' 연산 대상의 타입에 따라 문자열을 합치거나 더한다.
		- new 연산자는 타입에 정의된 크기만큼 저장 공간을 할당하고 생성된 객체를 초기화하기 위해 타입의 생성자를 자동으로 호출한다. 
	- 타입은 적용가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용된다.
- 객체지향 패러다임 관점의 타입
	- 객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메시지를 의미한다.
	- 타입은 호출가능한 오퍼레이션의 집합을 정의하므로 객체의 타입은 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이라고 할 수 있다.
	- 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.
	- 객체에게 중요한 것은 속성이 아니라 행동이다. 동일한 퍼블릭 인터페이스를 공유하는 객체는 동일한 타입으로 분류된다.
	- 객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다. 객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 외부에 제공하는 행동이다.


####  2. 타입 계층
- 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입을 슈퍼타입이라고 부르고 더 특수한 타입을 서브타입이라고 부른다.
- 슈퍼타입
	- 집합이 다른 집합의 모든 멤버를 포함한다.
	- 타입 정의가 다른 타입보다 좀 더 일반적이다.
- 서브타입
	- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
	- 타입 정의가 다른 타입보다 좀 더 구체적이다.
- 객체지향 프로그래밍과 타입계층 
	- 슈퍼타입: 더 일반적인 퍼블릭인터페이스를 가지는 객체들의 타입을 의미한다.
	- 서브타입: 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.
	- 서브 타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.

#### 3. 서브클래싱과 서브타이핑
- 상속을 이용해 타입 계층을 구현한다는 것은 부모 클래스가 슈퍼타입의 역할을, 자식 클래스가 서브타입의 역할을 수행하도록 클래스 사이의 관계를 정의한다는 것을 의미한다. 
- 서브타입이 되기 위해 만족해야하는 조건은?
- 서브타입의 퍼블릭 인터페이스가 슈퍼타입의 퍼블릭 인터페이스보다 더 특수하다는 것은 어떤 의미일까?

##### 언제 상속을 사용해야하는가? 
- 상속의 올바른 용도는 타입 계층을 구현하는 것이다. 
- 어떤 조건을 만족시켜야 올바르게 사용한걸까?
	- 상속관계가 is-a 관계를 모델링하는가?
		- 펭귄과 새: 그러나 어휘적인 정의가 아니라 기대되는 행동에 따라 타입계층을 구성해야한다.
	- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
		- 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야한다. 
		- 해당 조건을 우선적으로 충족시켜야 좋다. 
		- 타입의 이름 사이에 개념적으로 어떤 연관성이 있더라도 행동에 연관성이 없다면 상속을 사용하지 말아야한다.
		- 클라이언트 관점에서 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다. 
		- 그렇지 않고 동일하게 행동하지 않는 타입은 클라이언트의 기대에 따라 계층을 분리해야한다.
			- 상속 계층을 분리한다.
			- 인터페이스를 분리한다.
	- 인터페이스 분리 원칙 ISP 
		- 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계원칙
	- 설계는 현실을 100% 반영할 필요 없다. 현실적으로 필요한 수준만 반영하는것도 좋다. 

##### 서브 클래싱 
- 서브클래싱은 코드 재사용 목적으로 상속을 사용하는 경우를 가리킨다.
- 자식 클래스와 부모클래스의 행동이 호환되지 않아서 대체할 수 없다.

##### 서브 타이핑 
- 서브 타이핑은 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킨다. 인터페이스 상속이라고 부른다.
- 자식 클래스와 부모 클래스의 행동이 호환되며 대체 가능하다. 
- 서브 타입의 퍼블릭 인터페이스가 슈퍼타입에서 정의한 퍼블릭 인터페이스와 동일하거나 더 많은 오퍼레이션을 포함하고 있기 때문에 퍼블릭 인터페이스를 상속받는 것처럼 보인다.
- 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
	- 서브타입은 그것의 기반 타입에 대해 대체 가능해야한다. 
	- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야한다.
	- 그러므로 이 원칙은 클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드라인을 제공한다.
	- 클라이언트는 차이점을 인식하지 못한채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.
	- 정사각형은 직사각형의 서브타입이 될 수 없다.
	- 중요한 것은 클라이언트 관점에서 행동이 호환되는 지 여부다. 행동이 호환될 경우만 자식 클래스가 부모 클래스 대신 사용될 수 있다.
	- 클라이언트 관점에서 is - a 관계를 만족하는가?

#### 계약에 의한 설계와 서브타이핑
- 클라이언트 관점에서 자식 클래스가 부모 클래스를 대체할 수 있다는 것은 무엇을 의미하는가?
- 클라이언트 관점에서 자식 클래스가 부모 클래스의 행동을 보존한다는 것은 무엇을 의미하는가?
- 서브 타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 '계약'을 준수해야한다.
- 서브타입에 더 강력한 사전 조건을 정의할 수 없다. 같거나 더 약한 사전조건만을 정의할 수 있다.
- 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다. 더 약한 사후 조건을 정의할 수 없다.



### 14. 일관성 있는 협력

- 객체는 협력을 위해 존재한다. 협력은 객체가 존재하는 이유와 문맥을 제공한다.
- 잘 설계된 애플리케이션은 이해하기 쉽고, 수정이 용이하며, 재사용 가능한 협력의 모임이다.
- 객체지향 설계의 목표는 적절한 책임을 수행하는 객체들의 협력을 기반으로 결합도가 낮고 재사용 가능한 코드 구조를 창조하는 것이다.
- 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용해서 재사용하기 쉽게 객체들의 협력 방식을 일관성 있게 만들어야 한다.
- 어떻게 일관성있게 협력을 만들 수 있을까?

#### 일관성의 중요성
- 책임을 어떤 방식으로 할당하고 있는가? 일관된 방식인가? 
- 코드를 추가해도 일관성있게 관리할 수 있는가?
- 일관성 있는 코드는 개발자의 이해를 돕는다. 일관성 없는 코드가 비슷한 역할을 한다면 이해하기 더 어렵다.
- 유사한 기능은 유사한 방식으로 구현해야 한다.
- 협력을 일관성 있게 만들자. 
- 일관성 있는 설계를 만드러면?
	- 다양한 설계경험을 익히자.
	- 디자인 패턴을 학습하고 변경이라는 문맥안에서 디자인 패턴을 적용해보자
	- 디자인 패턴은 특정한 변경에 대해 일관성 있는 설계를 만들 수 있는 경험 법칙을 모아놓은 일종의 설계 템플릿이다.
	- 변하는 개념을 변하지 않는 개념으로부터 분리하라.
	- 변하는 개념을 캡슐화하라.

#### 클래스를 분리하기 위해 어떤 기준을 따르는 것이 좋을까?
- 가장 중요한 기준은 변경의 이유와 주기다. 
- 클래스는 명확히 단 하나의 이유에 의해서만 변경돼야 하고 클래스 안의 모든 코드는 함께 변경돼야 한다.
- 단일 책임 원칙을 따르도록 클래스를 분리해야한다.
- 시스템을 책임을 캡슐화한 섬들로 분리하고 그 섬들 간의 결합도를 제한하라. 

#### 캡슐화
- 캡슐화는 단순히 데이터를 은닉하는 목적으로 사용되는게 아니다.
- 캡슐화는 변할 수 있는 모든 개념을 감추는 것이다. 데이터만 감추는 게 아니다.
- 즉 코드 수정으로 인한 파급효과를 제어할 수 있는 모든 기법이 캡슐화의 일종이다.
- 객체의 퍼블릭 인터페이스와 구현을 분리해야하는 이유는 자주 변경되는 내부 구현을 숨길 수 있기 때문이다.
- 캡슐화의 종류
	- 데이터 캡슐화
	- 메서드 캡슐화
	- 객체 캡슐화: 합성
	- 서브타입 캡슐화: 인터페이스 상속 
- 협력을 일관성 있게 만들기 위해 서브타입 캡슐화와 객체 캡슐화를 조합하여 적용하기
	- 변하는 부분을 분리해서 타입 계층을 만든다.
	- 변하지 않는 부분의 일부로 타입 계층을 합성한다.

#### 변경을 캡슐화하기
- 변하는 부분과 변하지 않는 부분을 분리한다. 
- 변하는 부분의 공통점을 추상화한다.
- 변하지 않는 부분만을 이용해 객체 사이의 협력 관계를 설정하는게 좋다.
- 변하지 않는 요소와 추상적인 요소만으로도 전체적인 협력 구조를 설명할 수 있다.
- 변하지 않는 부분은 재사용할 수 있고 변하는 부분만 수정하면 되는 구조로 만드는게 좋다.
- 유사한 기능에 대해 유사한 협력 패턴을 적용하는 것은 객체지향 시스템에서 개념적 무결성을 유지할 수 있는 가장 효과적인 방법이다. 
 
 #### 일관성 있는 협력
 - 일관성 있는 협력의 핵심은 변경을 분리하고 캡슐화하는 것이다.
 - 유사한 변경이 지속적으로 발생하고 있다면 변경을 캡슐화할 수 있는 적절한 추상화를 찾은 후 이 추상화에 변하지 않는 공통의 책임을 할당하라.
 - 협력을 일관성있게 만드는 과정은 유사한 기능을 구현하기 위해 반복적으로 적용할 수 있는 협력의 구조를 찾아가는 긴 여정이다.
 - 객체지향 설계는 객체의 행동과 그것을 지원하기 위한 구조를 계속 수정해나가는 작업을 반복해나가면서 다듬어진다.

### 디자인 패턴과 프레임워크

- 디자인 패턴과 프레임워크는 모두 협력을 일관성있게 만들기 위한 방법이다. 

- 디자인 패턴
	- 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결방법이 디자인 패턴이다. 
	- 디자인 패턴을 익히면 변경의 방향과 주기를 이해하는 것만으로도 필요한 역할과 책임, 역할들의 협력방식을 순간적으로 떠올릴 수 있다.
	- 디자인 패턴은 특정한 변경을 일관성 있게 다룰 수 있는 협력 템플릿을 제공한다.

- 프레임워크
	- 프레임 워크는 설계와 코드를 함께 재사용하기 위해 사용할 수 있다.
	- 프레임 워크는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공하고 제공되는 아키텍처가 요구사항에 적합하다면 다양한 환경에서 테스트를 거친 견고한 구현 코드를 쉽게 빠르게 재사용할 수 있다.  
	- 프레임워크는 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다.

##### 디자인 패턴과 설계 재사용

- 패턴이란? 
	- 하나의 실무 컨텍스트에서 유용하게 사용해 왔고 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어다. 
	- 패턴의 경험의 산물이다.
	- 치열한 실무 현장에서 검증되었기 때문에 패턴을 익히면 유연하고 품질 높은 코드를 작성할 수 있다.
	- 소프트웨어 개발과 직접적인 연관성을 가진 분석, 설계, 구현 영역만으로 한정되는 것은 아니다. 다양한 크기의 프로젝트 조직을 구성하는 방법, 프로젝트 일정을 추정하는 방법, 스토리 카드나 백로그를 통해 요구사항을 관리하는 방법과 같이 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이 될 수 있다.
	- 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 패턴의 이름이다.

- 패턴과 책임 주도 설계
	- 객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 일이다.
	- 책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재사용성 등의 다양한 요소들의 트레이드오프를 통해 결정된다.
	- 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다. 
	- 패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 베스트 프렉티스다.
	- 패턴 적용시 책임 주도 설계의 절차를 하나하나 따르지 않아도 시스템 안에 구현할 객체들의 역할과 책임 협력 관계를 빠르고 손쉽게 구성할 수 있다. 
	- 패턴의 구성요소는 클래스가 아니라 역할이다. 

- 캡슐화와 디자인 패턴
	- 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의하고 있다.
	- 디자인 패턴의 목적은 특정한 변경을 캡슐화함으로써 유연하고 일관성있는 협력을 설계할 수 있는 경험을 공유하는 것이다. 
	- 디자인 패턴에서 중요한 것은 구현방법이나 구조가 아니라 어떤 변경을 캡슐화하는 것인지 이해하는 것이다. 변경을 캡슐화하기 위해 어떤 방법을 사용하는지 이해하자.

- 패턴은 출발점이다.
	- 패턴은 목표로 하는 설계에 이를 수 있는 방향을 제시하는 나침반과 같다. 패턴 자체가 설계의 목표가 아니다. 
	- 패턴을 맹목적으로 사용하는 것을 경계하라. 패턴을 적용하는 컨텍스트를 항상 분석해보자.
	- 해결하려는 문제가 아니라 패턴이 제시하는 구조를 맹목적으로 따르는 것은 불필요하게 복잡하고, 난해하며, 유지보수하기 어려운 시스템을 낳는다.
	- 명확한 트레이드오프 없이 패턴을 남용하면 설계가 불필요하게 복잡해진다. 꼭 필요할 때만 사용하자.
	- 패턴은 복잡성의 가치가 단순성을 넘어설때만 정당화된다.
	- 패턴을 지향하거나 패턴을 목표로 리팩터링 하는것이 패턴을 가장 효과적으로 적용하는 방법일 수 있다.
	- 문제를 분석하고 창의력을 발휘함으로써 패턴을 현재의 문제에 적합하도록 적절하게 수정하라.

##### 프레임워크와 코드 재사용
- 디자인 패턴은 프로그래밍 언어에 독립적으로 재사용 가능한 설계 아이디어를 제공하는 것을 목적으로 한다.
- 디자인 패턴을 적용하기 위해서는 설계 아이디어를 프로그래밍 언어의 특성에 맞춰 가공해야 하고 매번 구현 코드를 재작성해야한다.
- 설계를 재사용하면서도 유사한 코드를 반복적으로 구현하는 문제를 해결하기 위해 나온 것이 프레임워크다.

- 프레임 워크란? 
	- 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계다. 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격을 의미한다. 
	- 프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다.
	- 프레임워크는 애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함한다. 
	- 프레임워크는 애플리케이션을 확장할 수 있도록 부분적으로 구현된 추상 클래스와 인터페이스 집합 뿐만 아니라 추가적인 작업 없이도 재사용 가능한 다양한 컴포넌트도 함께 제공한다.

- 상위정책과 하위정책으로 패키지 분리
	- 프레임워크의 핵심은 추상화다. 추상클래스와 인터페이스가 가지는 어떤 특징이 프레임워크의 재사용성을 향상시키는 것인가? 
		- 추상 클래스와 인터페이스는 일관성있는 협력을 만드는 핵심 재료다.
		- 협력을 일관성있고 유연하게 만들기 위해서는 추상화를 이용해 변경을 캡슐화하고, 의존성은 추상화를 향하도록 작성해야한다. 
		- 변하는 것과 변하지 않는 것을 서로다른 주기로 배포할 수 있도록 배포 단위로 분리해야한다. 역할들의 협력구조인 상위정책과 구체적인 세부 사항을 서로 다른 패키지로 분리해야한다. 

