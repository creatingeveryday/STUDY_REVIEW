

# 오브젝트
- 복잡함을 어떻게 다룰 것인가? 
- 객체지향 프로그램을 설계하고 유지보수하기 위한 책
- 코드를 직접 쓰면서 개념과 이론을 익혀보자. 
- 1주일에 한 챕터씩 읽고 정리하자. 
- 읽으면서 개발 프로세스에 대해서 다시 한번 생각해보게 되었다. 

### 1. 객체, 설계

- 패러다임 쉬프트: 절차지향패러다임과 공존, 객체지향 패러다임이란? 언제 적용하는게 적합할까?
- 제대로 동작하고, 변경하기 쉽고, 이해하기 좋은 모듈을 만드려면?  
	- 변경하기 쉽다? 
		- 객체간 의존성을 최소한으로 유지할 것!
		- 변경되는 부분은 어떤 부분인가? 어떻게 관리해야하는가?
		- 결합도가 낮아야 한다. 
		- 응집도가 높아야 한다. 
	- 이해하기 좋다? 
		- 세부적인 내용을 한번에 기억해야하는 코드를 작성하지말자. 
		- 상식적으로 작성해야 이해하기 쉽다. 
	- 자율적인 존재, 캡슐화, 메시지로 의사소통, 책임(기능)의 분산
	- 자신의 데이터를 스스로 처리하는 자율적인 객체? 
	- 적절한 지점? 
	- 객체 지향적으로 모듈을 만들어야 변경에 용이하고 상식적으로 이해하기 좋다. 
	- => 결국 나의 시간과 같이 일하는 사람, 모두의 시간을 절약할 수 있는 모듈을 만드는게 핵심인 것 같다.
		- 내가 만든 모듈은 변경하기 쉽고 이해하기 좋은 모듈일까??? 이 책을 읽으면서 정말 그런가 생각해보게 됬다. 조금 더 고치면 더 좋은 모듈이 될 수 있지 않을까? 이 책을 읽으면서 조금씩 적용해봐야겠다. 
	- 특히나 이해하기 쉽게 코드를 작성하는 것은 실무에서 매우 중요하다.
	- 어떠한 기능을 설계하는 방법은 여러가지. 모두를 만족하는 설계는 존재하지 않는다. 
	- 설계는 균형의 예술.
	- 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다. 
	- 요구사항은 무조건 변화한다. 

### 2. 객체지향 프로그래밍 

- 객체 지향은 객체를 지향하는 것이다. 
- 클래스가 아닌 객체에 집중해야한다.
	- 어떤 클래스가 필요한지 고민하기전에 먼저 어떤 객체가 필요한지 고민하자.
	- 객체는 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원이다.
- 어떤 문제를 해결하는가? 
- 객체지향 패러다임이 강력한 이유는? 
	- 요구사항과 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있다.
	- 연결된다는 의미는?
	- 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있다.
- 실제로 코딩을 하기 전에 도메인구조와 그와 유사하게 클래스 구조를 미리 만들어야겠다. 
	- 클래스 내부와 외부의 경계를 분명히 정해야한다. -> 객체의 자율성 보장, 구현의 자유
	- 상태와 행동을 가진 자율적인 존재로 객체를 디자인해야한다. (데이터와 기능을 묶어서 캡슐화)
	- 어떤 객체가 어떻게 협력을 할 것인지 미리 생각해보자.
	- 도메인구조랑 클래스 구조를 미리 그릴때 어떤 점을 미리 생각해봐야될까?? 
		- 문제를 해결하기 위해 어떤 객체가 필요한가? 어떤 데이터를 저장하고 어떤 동작이 필요하지? 
		- 문제를 해결하기 위해 생성한 객체를 어떻게 협력하게 할까? 어떤 방식이 효율적인지 알기 위해서는  많은 경험이 필요할까?
		- 미래에 발생할 문제를 해결하기 위해 처음보는 사람도 쉽게 이해하기 쉬운 구조로 만들어야겠다. 
		- 문제를 해결하기 위해 만든 모듈을 그림으로 표현하기가 쉬운가? 이해하기도 쉬운가?
		- 인터페이스와 같은 추상적인 요소에 초점을 우선 맞추자. 
		- 
- 프로그래머의 역할을 언어, 프레임워크를 만드는 사람과 그렇게 만들어진 도구로 애플리케이션을 구축하는 사람으로 나눌 수 있다.
- 설계가 필요한 이유는 변경을 관리하기 위해서이다.  
- 내가 작성한 코드가 의미를 잘 전달할 수 있는지 확인...
- 메시지와 메서드를 구분하라
- 트레이드 오프 
	- 유연성과 가독성: 설계가 유연해질 수록 코드를 이해하고 디버깅하기 어려워진다. 유연성을 억제하면 코드를 이해하고 디버깅하기 쉬워지지만 재사용성과 확장가능성은 낮아진다.
- 상속 : 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 인터페이스 상속을 사용해야 변경에 유연한 코드를 작성할 수 있다.
- 다형성: 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다. 
- 추상화: 추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다. 
- 유연성이 필요한 곳에는 추상화를 사용하자. 
- 상속? 합성? 
	- 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법. 인터페이스에 정의된 메시지를 통해서만 코드를 재사용, 내부 구현에 대해 불필요한 부분을 알 필요는 없다.
	- 상속은 캡슐화를 위반하고 유연하지 못한 설계 방법이다.  클래스를 통해 강하게 결합되는 형태.
	- 상황을 살펴보고 적합한 방법을 선택해야한다. 
- 
### 3. 역할, 책임, 협력
- 객체지향 패러다임의 관점에서 객체지향 프로그래밍의 핵심은 역할, 책임, 협력이다. 
	- 협력: 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용
	- 책임: 객체가 협력에 참여하기 위해 수행하는 로직
	- 역할: 객체들이 협력안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다. 
- 어떻게 협력하는 객체의 공동체를 창조할 것인가? 
	- 객체 지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다. 
	- 클래스와 상속은 객체들의 책임과 협력이 어느 정도 자리를 잡은 후에 사용할 수 있는 구현 메커니즘일 뿐이다.
	- 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현에 초점을 맞추는 것은 변경화기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.
	- 자율적인 객체를 기본적으로 만드는 방법은 캡슐화. 변경의 전파를 제한해 변경하기 쉬워진다.
- 협력
	- 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다. 
	- 상태는 객체가 행동하는 데 필요한 정보에 의해 결정된다.
	- 행동은 협력 안에서 객체가 처리할 메시지로 결정된다. 
	- 협력은 객체를 설계하는데 필요한 일종의 문맥을 제공한다고 볼 수 있다. 
- 책임 
	- 협력에 참여하기 위해 객체가 수행하는 행동
	- 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다
	- 후보-책임-협력자(CRC) 카드와 같은 실재적이고 구체적인 툴을 활용하여 역할을 식별하고 책임을 할당하고 책임을 명시적으로 표현할 수 있다.  
	- 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보자. 
	- 책임 주도 설계
		- 시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다.
		- 시스템 책임을 더 작은 책임으로 분할한다. 
		- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다. 
		- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다. 
		- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. 
	- 메시지가 객체를 결정한다.
		- 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 결정한다. 
		- 그래야만 충분히 추상적이고 최소한의 인터페이스를 설정할 수 있다. 
	- 객체를 객체답게 만드는 것은 객체의 상태가 아니라 객체가 다른 객체에게 제공하는 행동이다. 
		- 객체의 내부구현에 초점을 맞추는 데이터 주도 설계는 캡슐화를 저해하고 의존하는 객체에게 변경이 전파된다. 
		- 상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일 뿐이다. 상태는 행동을 결정한 후에 결정해야 한다. 
		- 협력이라는 문맥 안에서 객체의 행동을 고민하자. 
- 역할 
	- 객체는 협력이라는 주어진 문맥 안에서 특정한 목적을 갖게 된다. 
	- 객체의 목적은 협력 안에서 객체가 맡게되는 책임의 집합으로 표시된다. 
	- 이처럼 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할이라고 부른다.
	- 협력 모델링시 역할에게 책임을 할당한다고 생각하는게 좋다. 
	- 역할은 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯이자 구체적인 객체들의 타입을 캡슐화하는 추상화
	- 협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용가능해진다는 것이다. 
	- 실전 팁
		- 현실적으로 도메인 모델 안에는 개념과 객체와 역할이 뒤섞여있다. 
		- 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야하고, 역할과 객체를명확하게 구분하는 것은 그렇게 중요하지 않다.
		- 단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할을 분리해내는 것이다
		- 중요한 것은 책임이다. 협력을 위해 어떤 책임이 필요한지 분명하게 이해해야한다. 

<3장 정리>
-  어떻게 협력하는 객체들의 공동체를 창조할 것인가?
    -   객체지향 프로그래밍의 핵심은 역할, 책임, 협력
    -   협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당한다.
    -   객체가 어떤 협력에 참여하고 있는지에 따라 객체의 행동(책임)을 결정하고, 객체의 행동에 따라 객체의 상태를  결정해야 한다.
-   그렇다면 어떻게 객체에게 적절한 책임이 할당되는가?
    -   우선  처리해야 할  메시지(요청)를 식별한다.
    -   요청을 처리할 책임을 수행하는데 필요한 정보를 가장 잘 아는 객체에게 메시지(요청)를 보낸다.
    -   메시지를 수신한 객체는 응답하기 위해 필요한 행동을 하게 되는데, 이 행동이 객체가 수행할 책임으로 이어진다.
    -   요청을 받은 객체는 요청에 응답하기 위해 필요한 행동(책임)을 수행한다. 이 과정에서 도움을 요청해서 처리해야할 메시지를 식별하고 다시 요청을 처리하는데 필요한 정보를 가장  잘 아는  객체에게 책임을 할당한다.
    -   이렇게 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이루어진다.

> 책임  할당 시  고려해야 할 2가지 요소  
> 1. 메시지가  객체를 결정한다.  
> 2. 행동이  상태를 결정한다. 협력이라는  문맥 아래에서  객체의 행동과 그 행동에 필요한 상태를  결정해야 한다.

-   배우라는 구체적인 객체에 책임을 할당하지 않고 배역이라는 역할 자체에 책임을 할당한다면?
    -   역할은 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯이자 구체적인 객체(배우)들의 타입을 캡슐화하는 추상화이다.  
    -   협력을 구체적인 객체(배우)가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고  재사용 가능해진다.
    -   추상 클래스와 인터페이스를 통해 역할을 구현할 수 있다.
    -   역할은 객체를 추상화해서 객체 자체가 아닌 협력에 초점을 맞출 수 있게 한다.

###  4. 설계 품질과 트레이드 오프
-	객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다. 
	-	설계는 변경을 위해 존재하고 변경에는 어떤 식으로든 비용이 발생한다. 휼륭한 설계란 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다.  객체의 행동에 초점을 맞추어 결합도와 응집도를 합리적인 수준으로 유지해야한다. 
	-	객체의 책임을 먼저 생각하라.

-	설계의 비교 기준
	-	캡슐화
		-	외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화
		-	변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개하여 변경의 여파를 통제하고 최소화하는가? 
		- 구현은 변경될 가능성이 높지만 인터페이스는 변경될 가능성이 낮다. 그래서 우리는 인터페이스를 공개해야한다.
		- 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화
		- 캡슐화하면 유지보수성이 향상되어 두려움 없이, 주저함 없이, 저항감 없이 코드를 변경할 수 있다.  	
		- 캡슐화의 정도가 응집도와 결합도를 결정한다. 
	-	응집도
		-	모듈에 포함된 내부 요소들이 연관돼 있는 정도
		-	모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 응집도가 높다고 말할 수 있다.
		-	객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는가? 
		-	변경이 발생할때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있으며, 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높고, 모듈의 일부가 변경된다면 응집도가 낮은 것이다. 
		-	응집도가 높을 수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다. 변경으로 인해 수정되는 부분을 파악하기 쉽고 여러 모듈을 수정할 필요 없이 오직 단 하나의 모듈만 수정하면된다. 
	-	결합도
		-	의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
		-	다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 결합도가 낮다고 말할 수 있다. 
		-	객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는가?
		-	한 모듈이 변경되기 위해서 다른 모듈의 변경을 얼마나 요구하는가? 
		-	낮은 결합도를 가지고 있다면 오직 하나의 모듈만 변경하면되지만, 높은 결합도를 가지고 있다면 다수의 모듈을 동시에 변경하기 때문에 낮은 결합도를 가져야 변경에 유리하다고 볼 수 있다.
		-	내부 구현이 변경될때 이것이 다른 모듈에 영향을 미치는 경우 결합도가 높다고 볼 수 있다.
		-	퍼블릭 인터페이스가 변경될때만 다른 모듈에 영향을 미치는 경우에는 결합도가 낮다고 볼 수 있다.  
	-	좋은 설계는 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다.
		-	높은 응집도와 낮은 결합도를 추구해야 좋은 설계를 만들 수 있다. 
		-	결국 응집도와 결합도는 변경과 관련된 것이다. 

-	좋은 설계와 나쁜 설계 비교해보기 
	- 데이터 중심 VS 책임 중심
	- 상태를 객체 분할의 중심축으로 생각하기 VS 책임을 객체 분할의 중심축으로 생각하기
	- 데이터 중심
		- 어떤 데이터를 객체 내부에 저장해야되는가? 
		- 데이터 중심의 관점에서 객체는 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의한다. 
		- 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할한다.
		- 객체의 상태에 초점을 맞춘다. 
		- 객체는 독립된 데이터 덩어리일뿐이다. 
		- 변경에 취약하다. 
		- 객체의 상태는 구현에 속하고 구현은 변하기 쉽다. 구현에 관한 세부 사항이 객체의 인터페이스에 영향을 주어 캡슐화의 원칙이 무너진다. 상태변경은 인터페이스의 변경을 초래하며 인터페이스에 의존하는 모든 객체에게 영향이 전파된다.
		- 데이터 중심 설계는 캡슐화를 위반하기 쉽다. 그러므로 결합도가 높고 응집도가 낮은 객체들을 양산하게될 가능성이 높다. 
		
	- 책임 중심
		- 책임 중심 관점에서 객체는 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관한다.
		-  객체의 행동에 초점을 맞춘다. 
		- 객체는 협력하는 공동체의 일원이다.
		- 상대적으로 변경에 안정적인 설계를 얻을 수 있다. 
		- 객체의 책임은 인터페이스에 속하므로 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다. 

- 데이터 중심 설계의 문제점
	- 캡슐화 위반
		- getter 와 setter 메서드를 사용했다고 캡슐화 원칙을 지키고 있다고 말할 수 있는가? 
			- 아니다. 그 메서드로 객체내부의 특정 변수가 존재한다고 퍼블릭 인터페이스에 노골적으로 드러낸다.
			- 캡슐화의 원칙을 어긴 근본적인 원인은 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 마주었기 때문이다. 중요한 것은 책임이며 구현을 캡슐화할 수 있는 적절한 책임은 협력이라는 문맥을 고려할 때만 얻을 수 있다. 
			-  접근자와 수정자에 과도하게 의존하는 설계 방식은 추측에 의한 설계 전략이라고 부른다. 객체가 어떤 협력에 참여할지 고려하지않고 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행하기 때문이다. 
			- 대부분의 내부 구현이 퍼블릭 인터페이스에 그대로 노출되며 변경에 매우 취약해진다.
		
			
	- 높은 결합도
		- 객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미한다.
		- 객체 내부의 구현을 변경하더라도 인터페이스 의존 하는 모든 클라이언트도 변경해야한다. 
		- 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체안에 집중되기 때문에 제어 객체를 함께 변경할 수 밖에 없는 상황이 발생한다. 
		- 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어버린다. 변경은 시스템 전체로 전파된다. 
		
		
	- 낮은 응집도
		- 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 할 수 있다. 
		- 하나의 요구사항을 변경하기 위해 동시에 여러 모듈을 수정해야 한다. 
		- 변경시 변경과 상관 없는 코드도 영향을 받는다. 

- 어떻게 개선할 것인가?
	- 캡슐화 원칙을 지킨다. 
		- 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야한다. 
			- 메서드는 단순히 속성에 대한 getter나 setter를 의미하지 않는다. 
			- 의미있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드다. 
			- getter 나 setter는 내부 구현을 인터페이스의 일부로 만들어 캡슐화를 위반한다.  
			-  getter 나 setter로 외부에서 객체를 하나씩 조작하지 말고 객체 스스로 자신의 상태를 관리하게 만들어서 캡슐화를 강화시킨다.
			
	- 객체 스스로 자신의 데이터를 책임지게 한다. 
		- 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다. 
		- 객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다. 
	- 