
# 오브젝트
- 복잡함을 어떻게 다룰 것인가? 
- 객체지향 프로그램을 설계하고 유지보수하기 위한 책
- 코드를 직접 쓰면서 개념과 이론을 익혀보자. 
- 1주일에 한 챕터씩 읽고 정리하자. 

### 1. 객체, 설계

- 패러다임 쉬프트: 절차지향패러다임과 공존, 객체지향 패러다임이란? 언제 적용하는게 적합할까?
- 제대로 동작하고, 변경하기 쉽고, 이해하기 좋은 모듈을 만드려면?  
	- 변경하기 쉽다? 
		- 객체간 의존성을 최소한으로 유지할 것!
		- 변경되는 부분은 어떤 부분인가? 어떻게 관리해야하는가?
		- 결합도가 낮아야 한다. 
		- 응집도가 높아야 한다. 
	- 이해하기 좋다? 
		- 세부적인 내용을 한번에 기억해야하는 코드를 작성하지말자. 
		- 상식적으로 작성해야 이해하기 쉽다. 
	- 자율적인 존재, 캡슐화, 메시지로 의사소통, 책임(기능)의 분산
	- 자신의 데이터를 스스로 처리하는 자율적인 객체? 
	- 적절한 지점? 
	- 객체 지향적으로 모듈을 만들어야 변경에 용이하고 상식적으로 이해하기 좋다. 
	- => 결국 나의 시간과 같이 일하는 사람, 모두의 시간을 절약할 수 있는 모듈을 만드는게 핵심인 것 같다.
		- 내가 만든 모듈은 변경하기 쉽고 이해하기 좋은 모듈일까??? 이 책을 읽으면서 정말 그런가 생각해보게 됬다. 조금 더 고치면 더 좋은 모듈이 될 수 있지 않을까? 이 책을 읽으면서 조금씩 적용해봐야겠다. 
	- 특히나 이해하기 쉽게 코드를 작성하는 것은 실무에서 매우 중요하다.
	- 어떠한 기능을 설계하는 방법은 여러가지. 모두를 만족하는 설계는 존재하지 않는다. 
	- 설계는 균형의 예술.
	- 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다. 
	- 요구사항은 무조건 변화한다. 

### 2. 객체지향 프로그래밍 

- 객체 지향은 객체를 지향하는 것이다. 
- 클래스가 아닌 객체에 집중해야한다.
	- 어떤 클래스가 필요한지 고민하기전에 먼저 어떤 객체가 필요한지 고민하자.
	- 객체는 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원이다.
- 어떤 문제를 해결하는가? 
- 객체지향 패러다임이 강력한 이유는? 
	- 요구사항과 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있다.
	- 연결된다는 의미는?
	- 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있다.
- 실제로 코딩을 하기 전에 도메인구조와 그와 유사하게 클래스 구조를 미리 만들어야겠다. 
	- 클래스 내부와 외부의 경계를 분명히 정해야한다. -> 객체의 자율성 보장, 구현의 자유
	- 상태와 행동을 가진 자율적인 존재로 객체를 디자인해야한다. (데이터와 기능을 묶어서 캡슐화)
	- 어떤 객체가 어떻게 협력을 할 것인지 미리 생각해보자.
	- 도메인구조랑 클래스 구조를 미리 그릴때 어떤 점을 미리 생각해봐야될까?? 
		- 문제를 해결하기 위해 어떤 객체가 필요한가? 어떤 데이터를 저장하고 어떤 동작이 필요하지? 
		- 문제를 해결하기 위해 생성한 객체를 어떻게 협력하게 할까? 어떤 방식이 효율적인지 알기 위해서는  많은 경험이 필요할까?
		- 미래에 발생할 문제를 해결하기 위해 처음보는 사람도 쉽게 이해하기 쉬운 구조로 만들어야겠다. 
		- 문제를 해결하기 위해 만든 모듈을 그림으로 표현하기가 쉬운가? 이해하기도 쉬운가?
		- 인터페이스와 같은 추상적인 요소에 초점을 우선 맞추자. 
		- 
- 프로그래머의 역할을 언어, 프레임워크를 만드는 사람과 그렇게 만들어진 도구로 애플리케이션을 구축하는 사람으로 나눌 수 있다.
- 설계가 필요한 이유는 변경을 관리하기 위해서이다.  
- 내가 작성한 코드가 의미를 잘 전달할 수 있는지 확인...
- 메시지와 메서드를 구분하라
- 트레이드 오프 
	- 유연성과 가독성: 설계가 유연해질 수록 코드를 이해하고 디버깅하기 어려워진다. 유연성을 억제하면 코드를 이해하고 디버깅하기 쉬워지지만 재사용성과 확장가능성은 낮아진다.
- 상속 : 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 인터페이스 상속을 사용해야 변경에 유연한 코드를 작성할 수 있다.
- 다형성: 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다. 
- 추상화: 추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다. 
- 유연성이 필요한 곳에는 추상화를 사용하자. 
- 상속? 합성? 
	- 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법. 인터페이스에 정의된 메시지를 통해서만 코드를 재사용, 내부 구현에 대해 불필요한 부분을 알 필요는 없다.
	- 상속은 캡슐화를 위반하고 유연하지 못한 설계 방법이다.  클래스를 통해 강하게 결합되는 형태.
	- 상황을 살펴보고 적합한 방법을 선택해야한다. 
- 
### 3. 역할, 책임, 협력
- 객체지향 패러다임의 관점에서 객체지향 프로그래밍의 핵심은 역할, 책임, 협력이다. 
	- 협력: 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용
	- 책임: 객체가 협력에 참여하기 위해 수행하는 로직
	- 역할: 객체들이 협력안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다. 
- 어떻게 협력하는 객체의 공동체를 창조할 것인가? 
	- 객체 지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다. 
	- 클래스와 상속은 객체들의 책임과 협력이 어느 정도 자리를 잡은 후에 사용할 수 있는 구현 메커니즘일 뿐이다.
	- 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현에 초점을 맞추는 것은 변경화기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.
	- 자율적인 객체를 기본적으로 만드는 방법은 캡슐화. 변경의 전파를 제한해 변경하기 쉬워진다.
- 협력
	- 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다. 
	- 상태는 객체가 행동하는 데 필요한 정보에 의해 결정된다.
	- 행동은 협력 안에서 객체가 처리할 메시지로 결정된다. 
	- 협력은 객체를 설계하는데 필요한 일종의 문맥을 제공한다고 볼 수 있다. 
- 책임 
	- 협력에 참여하기 위해 객체가 수행하는 행동
	- 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다
	- 후보-책임-협력자 CRC 카드와 같은 실재적이고 구체적인 툴을 활용하여 역할을 식별하고 책임을 할당하고 책임을 명시적으로 표현할 수 있다.  
	- 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보자. 
	- 책임 주도 설계
		- 시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다.
		- 시스템 책임을 더 작은 책임으로 분할한다. 
		- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다. 
		- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다. 
		- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. 
		- 
	- 
-  