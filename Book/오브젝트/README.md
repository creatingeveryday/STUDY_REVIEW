

# 오브젝트
- 복잡함을 어떻게 다룰 것인가? 
- 객체지향 프로그램을 설계하고 유지보수하기 위한 책
- 코드를 직접 쓰면서 개념과 이론을 익혀보자. 
- 1주일에 한 챕터씩 읽고 정리하자. 
- 읽으면서 개발 프로세스에 대해서 다시 한번 생각해보게 되었다. 

### 1. 객체, 설계

- 패러다임 쉬프트: 절차지향패러다임과 공존, 객체지향 패러다임이란? 언제 적용하는게 적합할까?
- 제대로 동작하고, 변경하기 쉽고, 이해하기 좋은 모듈을 만드려면?  
	- 변경하기 쉽다? 
		- 객체간 의존성을 최소한으로 유지할 것!
		- 변경되는 부분은 어떤 부분인가? 어떻게 관리해야하는가?
		- 결합도가 낮아야 한다. 
		- 응집도가 높아야 한다. 
	- 이해하기 좋다? 
		- 세부적인 내용을 한번에 기억해야하는 코드를 작성하지말자. 
		- 상식적으로 작성해야 이해하기 쉽다. 
	- 자율적인 존재, 캡슐화, 메시지로 의사소통, 책임(기능)의 분산
	- 자신의 데이터를 스스로 처리하는 자율적인 객체? 
	- 적절한 지점? 
	- 객체 지향적으로 모듈을 만들어야 변경에 용이하고 상식적으로 이해하기 좋다. 
	- => 결국 나의 시간과 같이 일하는 사람, 모두의 시간을 절약할 수 있는 모듈을 만드는게 핵심인 것 같다.
		- 내가 만든 모듈은 변경하기 쉽고 이해하기 좋은 모듈일까??? 이 책을 읽으면서 정말 그런가 생각해보게 됬다. 조금 더 고치면 더 좋은 모듈이 될 수 있지 않을까? 이 책을 읽으면서 조금씩 적용해봐야겠다. 
	- 특히나 이해하기 쉽게 코드를 작성하는 것은 실무에서 매우 중요하다.
	- 어떠한 기능을 설계하는 방법은 여러가지. 모두를 만족하는 설계는 존재하지 않는다. 
	- 설계는 균형의 예술.
	- 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다. 
	- 요구사항은 무조건 변화한다. 

### 2. 객체지향 프로그래밍 

- 객체 지향은 객체를 지향하는 것이다. 
- 클래스가 아닌 객체에 집중해야한다.
	- 어떤 클래스가 필요한지 고민하기전에 먼저 어떤 객체가 필요한지 고민하자.
	- 객체는 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원이다.
- 어떤 문제를 해결하는가? 
- 객체지향 패러다임이 강력한 이유는? 
	- 요구사항과 프로그램을 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 매끄럽게 연결될 수 있다.
	- 연결된다는 의미는?
	- 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있다.
- 실제로 코딩을 하기 전에 도메인구조와 그와 유사하게 클래스 구조를 미리 만들어야겠다. 
	- 클래스 내부와 외부의 경계를 분명히 정해야한다. -> 객체의 자율성 보장, 구현의 자유
	- 상태와 행동을 가진 자율적인 존재로 객체를 디자인해야한다. (데이터와 기능을 묶어서 캡슐화)
	- 어떤 객체가 어떻게 협력을 할 것인지 미리 생각해보자.
	- 도메인구조랑 클래스 구조를 미리 그릴때 어떤 점을 미리 생각해봐야될까?? 
		- 문제를 해결하기 위해 어떤 객체가 필요한가? 어떤 데이터를 저장하고 어떤 동작이 필요하지? 
		- 문제를 해결하기 위해 생성한 객체를 어떻게 협력하게 할까? 어떤 방식이 효율적인지 알기 위해서는  많은 경험이 필요할까?
		- 미래에 발생할 문제를 해결하기 위해 처음보는 사람도 쉽게 이해하기 쉬운 구조로 만들어야겠다. 
		- 문제를 해결하기 위해 만든 모듈을 그림으로 표현하기가 쉬운가? 이해하기도 쉬운가?
		- 인터페이스와 같은 추상적인 요소에 초점을 우선 맞추자. 
		- 
- 프로그래머의 역할을 언어, 프레임워크를 만드는 사람과 그렇게 만들어진 도구로 애플리케이션을 구축하는 사람으로 나눌 수 있다.
- 설계가 필요한 이유는 변경을 관리하기 위해서이다.  
- 내가 작성한 코드가 의미를 잘 전달할 수 있는지 확인...
- 메시지와 메서드를 구분하라
- 트레이드 오프 
	- 유연성과 가독성: 설계가 유연해질 수록 코드를 이해하고 디버깅하기 어려워진다. 유연성을 억제하면 코드를 이해하고 디버깅하기 쉬워지지만 재사용성과 확장가능성은 낮아진다.
- 상속 : 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 인터페이스 상속을 사용해야 변경에 유연한 코드를 작성할 수 있다.
- 다형성: 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 의미한다. 
- 추상화: 추상화를 이용해 상위 정책을 기술한다는 것은 기본적인 애플리케이션의 협력 흐름을 기술한다는 것을 의미한다. 
- 유연성이 필요한 곳에는 추상화를 사용하자. 
- 상속? 합성? 
	- 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법. 인터페이스에 정의된 메시지를 통해서만 코드를 재사용, 내부 구현에 대해 불필요한 부분을 알 필요는 없다.
	- 상속은 캡슐화를 위반하고 유연하지 못한 설계 방법이다.  클래스를 통해 강하게 결합되는 형태.
	- 상황을 살펴보고 적합한 방법을 선택해야한다. 
- 
### 3. 역할, 책임, 협력
- 객체지향 패러다임의 관점에서 객체지향 프로그래밍의 핵심은 역할, 책임, 협력이다. 
	- 협력: 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용
	- 책임: 객체가 협력에 참여하기 위해 수행하는 로직
	- 역할: 객체들이 협력안에서 수행하는 책임들이 모여 객체가 수행하는 역할을 구성한다. 
- 어떻게 협력하는 객체의 공동체를 창조할 것인가? 
	- 객체 지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다. 
	- 클래스와 상속은 객체들의 책임과 협력이 어느 정도 자리를 잡은 후에 사용할 수 있는 구현 메커니즘일 뿐이다.
	- 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현에 초점을 맞추는 것은 변경화기 어렵고 유연하지 못한 코드를 낳는 원인이 된다.
	- 자율적인 객체를 기본적으로 만드는 방법은 캡슐화. 변경의 전파를 제한해 변경하기 쉬워진다.
- 협력
	- 객체의 행동을 결정하는 것은 객체가 참여하고 있는 협력이다. 
	- 상태는 객체가 행동하는 데 필요한 정보에 의해 결정된다.
	- 행동은 협력 안에서 객체가 처리할 메시지로 결정된다. 
	- 협력은 객체를 설계하는데 필요한 일종의 문맥을 제공한다고 볼 수 있다. 
- 책임 
	- 협력에 참여하기 위해 객체가 수행하는 행동
	- 객체에게 할당한 책임이 외부의 인터페이스와 내부의 속성을 결정한다
	- 후보-책임-협력자(CRC) 카드와 같은 실재적이고 구체적인 툴을 활용하여 역할을 식별하고 책임을 할당하고 책임을 명시적으로 표현할 수 있다.  
	- 시스템이 사용자에게 제공하는 기능을 시스템이 담당할 하나의 책임으로 바라보자. 
	- 책임 주도 설계
		- 시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다.
		- 시스템 책임을 더 작은 책임으로 분할한다. 
		- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다. 
		- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다. 
		- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. 
	- 메시지가 객체를 결정한다.
		- 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 결정한다. 
		- 그래야만 충분히 추상적이고 최소한의 인터페이스를 설정할 수 있다. 
	- 객체를 객체답게 만드는 것은 객체의 상태가 아니라 객체가 다른 객체에게 제공하는 행동이다. 
		- 객체의 내부구현에 초점을 맞추는 데이터 주도 설계는 캡슐화를 저해하고 의존하는 객체에게 변경이 전파된다. 
		- 상태는 단지 객체가 행동을 정상적으로 수행하기 위해 필요한 재료일 뿐이다. 상태는 행동을 결정한 후에 결정해야 한다. 
		- 협력이라는 문맥 안에서 객체의 행동을 고민하자. 
- 역할 
	- 객체는 협력이라는 주어진 문맥 안에서 특정한 목적을 갖게 된다. 
	- 객체의 목적은 협력 안에서 객체가 맡게되는 책임의 집합으로 표시된다. 
	- 이처럼 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할이라고 부른다.
	- 협력 모델링시 역할에게 책임을 할당한다고 생각하는게 좋다. 
	- 역할은 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯이자 구체적인 객체들의 타입을 캡슐화하는 추상화
	- 협력을 구체적인 객체가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고 재사용가능해진다는 것이다. 
	- 실전 팁
		- 현실적으로 도메인 모델 안에는 개념과 객체와 역할이 뒤섞여있다. 
		- 설계 초반에는 적절한 책임과 협력의 큰 그림을 탐색하는 것이 가장 중요한 목표여야하고, 역할과 객체를명확하게 구분하는 것은 그렇게 중요하지 않다.
		- 단순하게 객체로 시작하고 반복적으로 책임과 협력을 정제해가면서 필요한 순간에 객체로부터 역할을 분리해내는 것이다
		- 중요한 것은 책임이다. 협력을 위해 어떤 책임이 필요한지 분명하게 이해해야한다. 

<3장 정리>
-  어떻게 협력하는 객체들의 공동체를 창조할 것인가?
    -   객체지향 프로그래밍의 핵심은 역할, 책임, 협력
    -   협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당한다.
    -   객체가 어떤 협력에 참여하고 있는지에 따라 객체의 행동(책임)을 결정하고, 객체의 행동에 따라 객체의 상태를  결정해야 한다.
-   그렇다면 어떻게 객체에게 적절한 책임이 할당되는가?
    -   우선  처리해야 할  메시지(요청)를 식별한다.
    -   요청을 처리할 책임을 수행하는데 필요한 정보를 가장 잘 아는 객체에게 메시지(요청)를 보낸다.
    -   메시지를 수신한 객체는 응답하기 위해 필요한 행동을 하게 되는데, 이 행동이 객체가 수행할 책임으로 이어진다.
    -   요청을 받은 객체는 요청에 응답하기 위해 필요한 행동(책임)을 수행한다. 이 과정에서 도움을 요청해서 처리해야할 메시지를 식별하고 다시 요청을 처리하는데 필요한 정보를 가장  잘 아는  객체에게 책임을 할당한다.
    -   이렇게 협력에 필요한 메시지를 찾고 메시지에 적절한 객체를 선택하는 반복적인 과정을 통해 이루어진다.

> 책임  할당 시  고려해야 할 2가지 요소  
> 1. 메시지가  객체를 결정한다.  
> 2. 행동이  상태를 결정한다. 협력이라는  문맥 아래에서  객체의 행동과 그 행동에 필요한 상태를  결정해야 한다.

-   배우라는 구체적인 객체에 책임을 할당하지 않고 배역이라는 역할 자체에 책임을 할당한다면?
    -   역할은 다양한 종류의 객체를 수용할 수 있는 일종의 슬롯이자 구체적인 객체(배우)들의 타입을 캡슐화하는 추상화이다.  
    -   협력을 구체적인 객체(배우)가 아니라 추상적인 역할의 관점에서 설계하면 협력이 유연하고  재사용 가능해진다.
    -   추상 클래스와 인터페이스를 통해 역할을 구현할 수 있다.
    -   역할은 객체를 추상화해서 객체 자체가 아닌 협력에 초점을 맞출 수 있게 한다.

###  4. 설계 품질과 트레이드 오프
-	객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다. 
	-	설계는 변경을 위해 존재하고 변경에는 어떤 식으로든 비용이 발생한다. 휼륭한 설계란 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다.  객체의 행동에 초점을 맞추어 결합도와 응집도를 합리적인 수준으로 유지해야한다. 
	-	객체의 책임을 먼저 생각하라.

-	설계의 비교 기준
	-	캡슐화
		-	외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화
		-	변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개하여 변경의 여파를 통제하고 최소화하는가? 
		- 구현은 변경될 가능성이 높지만 인터페이스는 변경될 가능성이 낮다. 그래서 우리는 인터페이스를 공개해야한다.
		- 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화
		- 캡슐화하면 유지보수성이 향상되어 두려움 없이, 주저함 없이, 저항감 없이 코드를 변경할 수 있다.  	
		- 캡슐화의 정도가 응집도와 결합도를 결정한다. 
	-	응집도
		-	모듈에 포함된 내부 요소들이 연관돼 있는 정도
		-	모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 응집도가 높다고 말할 수 있다.
		-	객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는가? 
		-	변경이 발생할때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있으며, 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면 응집도가 높고, 모듈의 일부가 변경된다면 응집도가 낮은 것이다. 
		-	응집도가 높을 수록 변경의 대상과 범위가 명확해지기 때문에 코드를 변경하기 쉬워진다. 변경으로 인해 수정되는 부분을 파악하기 쉽고 여러 모듈을 수정할 필요 없이 오직 단 하나의 모듈만 수정하면된다. 
	-	결합도
		-	의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
		-	다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 결합도가 낮다고 말할 수 있다. 
		-	객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는가?
		-	한 모듈이 변경되기 위해서 다른 모듈의 변경을 얼마나 요구하는가? 
		-	낮은 결합도를 가지고 있다면 오직 하나의 모듈만 변경하면되지만, 높은 결합도를 가지고 있다면 다수의 모듈을 동시에 변경하기 때문에 낮은 결합도를 가져야 변경에 유리하다고 볼 수 있다.
		-	내부 구현이 변경될때 이것이 다른 모듈에 영향을 미치는 경우 결합도가 높다고 볼 수 있다.
		-	퍼블릭 인터페이스가 변경될때만 다른 모듈에 영향을 미치는 경우에는 결합도가 낮다고 볼 수 있다.  
	-	좋은 설계는 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다.
		-	높은 응집도와 낮은 결합도를 추구해야 좋은 설계를 만들 수 있다. 
		-	결국 응집도와 결합도는 변경과 관련된 것이다. 

-	좋은 설계와 나쁜 설계 비교해보기 
	- 데이터 중심 VS 책임 중심
	- 상태를 객체 분할의 중심축으로 생각하기 VS 책임을 객체 분할의 중심축으로 생각하기
	- 데이터 중심
		- 어떤 데이터를 객체 내부에 저장해야되는가? 
		- 데이터 중심의 관점에서 객체는 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의한다. 
		- 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할한다.
		- 객체의 상태에 초점을 맞춘다. 
		- 객체는 독립된 데이터 덩어리일뿐이다. 
		- 변경에 취약하다. 
		- 객체의 상태는 구현에 속하고 구현은 변하기 쉽다. 구현에 관한 세부 사항이 객체의 인터페이스에 영향을 주어 캡슐화의 원칙이 무너진다. 상태변경은 인터페이스의 변경을 초래하며 인터페이스에 의존하는 모든 객체에게 영향이 전파된다.
		- 데이터 중심 설계는 캡슐화를 위반하기 쉽다. 그러므로 결합도가 높고 응집도가 낮은 객체들을 양산하게될 가능성이 높다. 
		
	- 책임 중심
		- 책임 중심 관점에서 객체는 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관한다.
		-  객체의 행동에 초점을 맞춘다. 
		- 객체는 협력하는 공동체의 일원이다.
		- 상대적으로 변경에 안정적인 설계를 얻을 수 있다. 
		- 객체의 책임은 인터페이스에 속하므로 객체는 책임을 드러내는 안정적인 인터페이스 뒤로 책임을 수행하는데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다. 

- 데이터 중심 설계의 문제점
	- 캡슐화 위반
		- ***getter 와 setter 메서드를 사용했다고 캡슐화 원칙을 지키고 있다고 말할 수 있는가?***
			- 아니다. 그 메서드로 객체내부의 특정 변수가 존재한다고 퍼블릭 인터페이스에 노골적으로 드러낸다.
			- 캡슐화의 원칙을 어긴 근본적인 원인은 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 마주었기 때문이다. 중요한 것은 책임이며 구현을 캡슐화할 수 있는 적절한 책임은 협력이라는 문맥을 고려할 때만 얻을 수 있다. 
			-  접근자와 수정자에 과도하게 의존하는 설계 방식은 추측에 의한 설계 전략이라고 부른다. 객체가 어떤 협력에 참여할지 고려하지않고 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행하기 때문이다. 
			- 대부분의 내부 구현이 퍼블릭 인터페이스에 그대로 노출되며 변경에 매우 취약해진다.
		
			
	- 높은 결합도
		- 객체 내부의 구현이 객체의 인터페이스에 드러난다는 것은 클라이언트가 구현에 강하게 결합된다는 것을 의미한다.
		- 객체 내부의 구현을 변경하더라도 인터페이스 의존 하는 모든 클라이언트도 변경해야한다. 
		- 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체안에 집중되기 때문에 제어 객체를 함께 변경할 수 밖에 없는 상황이 발생한다. 
		- 전체 시스템을 하나의 거대한 의존성 덩어리로 만들어버린다. 변경은 시스템 전체로 전파된다. 
		
		
	- 낮은 응집도
		- 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 할 수 있다. 
		- 하나의 요구사항을 변경하기 위해 동시에 여러 모듈을 수정해야 한다. 
		- 변경시 변경과 상관 없는 코드도 영향을 받는다. 

- 어떻게 개선할 것인가?
	- 캡슐화 원칙을 지킨다. 
		- 객체는 스스로의 상태를 책임져야 하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야한다. 
			- 메서드는 단순히 속성에 대한 getter나 setter를 의미하지 않는다. 
			- 의미있는 메서드는 객체가 책임져야 하는 무언가를 수행하는 메서드다. 
			- getter 나 setter는 내부 구현을 인터페이스의 일부로 만들어 캡슐화를 위반한다.  
			-  getter 나 setter로 외부에서 객체를 하나씩 조작하지 말고 객체 스스로 자신의 상태를 관리하게 만들어서 캡슐화를 강화시킨다.
			
	- 객체 스스로 자신의 데이터를 책임지게 한다. 
		- 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다. 
		- 객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다. 
	- 그래도 한계점은 존재한다. 
		- 캡슐화 위반
			- 내부 구현의 변경이 외부로 퍼져나가는 파급효과가 여전히 발생한다면 캡슐화 실패로 봐야한다.
			- 캡슐화는 변경될 수 있는 모든 것을 감추는 것을 의미한다. 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화해야한다.  
			- 캡슐화를 위반하면 높은 결합도와 낮은 응집도라는 결과를 불러온다. 
		- 왜 이런 문제점이 발생하는가? 
			- 데이터 중심 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
				- 객체의 행동보다 상태에 초점을 맞춘다. 
			- 데이터 중심 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

- 더 생각해볼 부분
	- 메시지를 발견하고 책임을 할당했다면 그 이후에 어떻게 응집도와 결합도가 높게 구현해나가는가?  
	- 어떻게 내부 구현 변경이 외부로 전파되는 것을 차단할까? 
	- 기존 모듈이 캡슐화 원칙이 위반된 경우 어떻게 대처해야할까? 
			 
### 5. 책임 할당하기
- 왜 책임에 초점을 맞춰야하는가? 
	- 데이터 중심 설계는 행동보다 데이터를 먼저 결정하고 협력이라는 문맥을 벗어나 고립된 상태의 객체에 초점을 맞추기 때문에 캡슐화를 위반하기 쉽고, 결합도가 높아지고, 응집도가 낮아지며, 코드를 변경하기 어려워진다. 
	- 이러한 문제점을 해결할 수 있는 가장 기본적인 방법은 책임에 초점을 맞추는 것이다.
	- 그런데 어떤 객체에게 어떤 책임을 할당할지 결정하는 것이 쉽지 않다. 
	- 동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라진다. 
	- 그러므로 다양한 관점에서 설계를 평가해야만 올바르게 책임을 할당할 수 있다. 

- 어떻게 책임 할당의 어려움을 해결할 것인가? 우선 기본적인 원칙을 지켜야한다. 
	- 데이터가 아니라 객체의 책임과 협력에 초점을 맞추어라. 
		- 데이터 보다 행동을 먼저 결정하라.
			- 협력에 참여하기 위해 어떤 행동이 필요한가? 를 먼저 묻고 그 행동에 필요한 데이터를 결정해야한다는 것이다. 
			- 어떤 행동이 필요한지 알기 위해서는 먼저 어떤 상황인지 협력이라는 문맥을 파악해야한다.  
		- 협력이라는 문맥 안에서 책임을 결정하라. 
			- 객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정된다. 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야한다. 
			- 협력을 시작하는 주체는 메시지 전송자이므로 메시지 전송자에 적합한 책임이 협력에 적합한 책임이다. 
			- 메세지를 결정한 후에 객체를 선택해야한다. 메시지가 존재하기 때문에 그 메시지를 처리할 객체가 필요한 것이다. 
			- 클라이언트는 단지 임의의 객체가 메시지를 수신할 것이라는 사실을 믿고 자신의 의도를 표현한 메시지를 전송할 뿐이다. 그리고 메시지를 수신하기로 결정된 객체는 메시지를 처리할 책임을 할당받게 된다.
			- 메시지 송신자는 메시지 수신자를 모르기 때문에 캡슐화가 잘 지켜진다. 
			
	- 책임할당을 위한 GRASP 패턴 (General Responsibility Assignment Software Pattern)
		- 설계를 시작하기 전 도메인에 대한 개략적인 모습을 그려보자. 
			- 도메인 개념을 책임 할당의 대상으로 사용하면 코드에 도메인을 투영하기가 좀 더 수월해진다.
			- 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다. 
			- 올바른 도메인 모델이라는 정답은 없다. 올바른 구현을 이끌어 낼수 있다면 충분하다. 실용적으로 접근하자.
			- 실제로 코드로 구현해나가면서 유연성이나 재사용성을 위해서 도메인 모델을 역으로 바꾸기도 한다. 
			
		- Information Pattern: 정보 전문가에게 책임을 할당하라. 
			- 애플리케이션이 제공해야 하는 기능을 책임으로 생각해야한다.
			- 책임은 전송된 메시지(요청)이며 애플리케이션은 이 책임을 수행해야할 의무가 있다.
			- 이제 이 책임을 수행하는데 필요한 메시지를 결정해야한다. ex) 예매하라! 
			- 메시지를 결정했다면 메시지를 수신할 적합한 객체를 선택해야한다. 
				- 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하자. 
				- 정보를 알고 있다는 것은 저장하고 있다는 것과 다르다.
				- 해당 정보를 제공할 수 있는 다른 객체를 알고 있으면 휼륭하게 책임을 수행할 수 있다.
			- 메시지를 수신할 객체가 정해졌다면 해당 객체가 책임을 수행하는데 필요한 작업을 구상해보고 스스로 처리할 수 없는 작업이 무엇인지 가려내야한다.
			- 스스로 처리할 수 없는 작업은 외부에 도움을 요청해야하며 이 도움 요청이 외부로 전송해야하는 새로운 메시지가 된다. 
		- Low Coupling Pattern: 낮은 결합도를 유지하도록 책임을 할당하라.
			- 의존성을 낮추고 변화의 영향을 줄이면서 재사용성을 증가시킬 수 있다.
		- High Cohesion Pattern: 높은 응집도를 유지하도록 책임을 할당하라.
			- 서로 다른 이유로 변경되는 책임을 짊어지게 되면 응집도가 낮아지고 변경하기 어렵게 된다. 
		- Creator Pattern: 창조자에게 객체 생성 책임을 할당하라. 
			- 객체 A를 생성할 때 어떤 객체에게 객체 생성 책임을 할당해야하는가? 아래의 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라. 
				- B가 A 객체를 포함하거나 참조한다.
				- B가 A 객체를 기록한다.
				- B가 A 객체를 긴밀하게 사용한다.
				- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다. ( B는 A에 대한 정보 전문가)
			- 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.
			- 이미 결합되어있기 때문에 책임을 할당하더라도 설계 전체의 결합도에 영향을 미치지 않는다. 
		
		- 이렇게 대략적으로 구상을 해보았다면 이제 실제로 협력과 책임이 제대로 동작하는지 코드를 작성하면서 확인해야한다.
			- 메시지의 시그니처는 메시지 송신객체의 의도를 표현하게 만든다.
			- 메시지가 객체간의 유일한 연결고리가 되면 캡슐화 원칙을 잘 지킬 수 있다. 
			
			- 낮은 응집도의 모듈은 변경의 이유에 따라 클래스를 분리해야한다.
				- 변경의 이유가 하나 이상인 클래스는 낮은 응집도를 가지기 때문이다.
				- 응집도가 낮은 모듈을 어떻게 찾을 수 있을까? 
					- 클래스의 인스턴스 변수를 초기화 할때 모든 속성이 초기화 되지 않고 일부 속성만 초기화된다면? 
						- 함께 초기화 되는 속성을 기준으로 코드를 분리해야한다.
					- 메서드가 인스턴스 변수를 모두 사용하지 않고 일부만 사용한다면?
						-  해당 인스턴스 속성과 메서드 그룹을 기준으로 코드를 분리해야한다. 
			- Polymorphism Pattern: 인터페이스를 활용해 분리한 클래스를 동일한 역할을 수행하게 한다. 
				- 객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당하는 것이다.
				- 조건 논리는 변경에 취약하다. 
				
			-  Protected Variations Pattern: 변경을 캡슐화하도록 책임을 할당하라. 
				- 객체지향 설계를 할 때 도메인에 대한 이해가 필수적으로 요구되는 이유는? 
				- 캡슐화하기 위해서는 변경될 부분을 미리 식별할 수 있어야 한다. 
				- 도메인의 구조가 코드의 구조를 이끈다.
				- 변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라.
				
			- 설계시 변경에 대처하는 2가지 방법
				- 1 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것이다.
				- 2 다른 하나는 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것이다.
				- 대부분의 경우 최대한 단순하게 설계하는 방법이 좋지만 변경이 반복적으로 발생하는 경우 복잡성이 조금 상승하더라도 유연성을 추가하는 2번째 방법이 더좋다고 한다. 번거로움과 실수를 줄여주어 오류를 줄일 수 있다. 
			- 코드의 구조가 도메인의 구조에 대한 새로운 통찰력을 제공한다.
				- 실제로 코드를 작성하던 중  도메인의 요구사항을 수용하기 위해 코드의 구조를 수정한다면? 
				- 도메인 모델 역시 코드의 관점에 따라 바뀌어야 한다.
				- 수정된 도메인 모델은 도메인에 포함된 개념과 관계뿐만 아니라 도메인이 요구하는 유연성도 정확하게 반영한다. 
				- 도메인 모델은 구현과 밀접한 관계를 맺고 있다.
				- 도메인 모델은 코드에 대한 가이드를 제공할 수 있어야 하며 코드의 변화에 발맞춰 함께 변화해야한다. 
				- 도메인 모델은 코드와 분리되어 있지 않다.
				
			- Refactoring : 이해하기 쉽고 수정하기 쉬운 소프트웨어로 개선하기 위해 겉으로 보이는 동작은 바꾸지 않은 채 내부 구조를 변경하는 것이다.  
				- 사실 책임 할당은 쉽지 않은 문제다. 도메인에 대한 이해가 필수적으로 요구되고 책임 할당도 난해하고 어렵다. 
				- 그래서 대부분 객체지향 언어로 절차형 프로그램을 작성하기 쉽다. 
				- 하나의 해결 방법으로 먼저 절차형 프로그램을 작성후에 객체지향적인 코드로 변경하는 리팩터링이라고 부르는 차선책이 존재한다. 
				- 기존 동작은 유지하되 내부 구조를 유연하게(높은 응집도, 낮은 결합도) 변경할 수 있다. 
				- 여러가지 일을 처리하는 긴 메서드를 분해하여 응집도를 높이자. 
					- 클래스가 작고,  목적이 명확한 메서드들로 구성돼 있다면 변경을 처리하기 위해 어떤 메서드를 수정해야 하는지를 쉽게 판단할 수 있다. 
					- 메서드의 크기가 작고 목적이 분명하기 때문에 재사용도 쉬워진다.
					- 작은 메서드들로 조합된 메서드는 마치 주석들을 나열한 것처럼 보이기 때문에 코드를 이해하기도 쉽다. 
					- 한 눈에 알아볼 수 있게 만들면 좋다.
					- 동시에 너무 많은 세부사항을 기억하도록 강요하는 코드는 이해하기 어렵기 때문이다. 메서드의 세부구현은 필요시 확인할 수 있게 메서드를 쪼개어 구현한다. 
					- 작고, 명확하고, 한 가지 일에 집중하는 응집도 높은 메서드는 변경 가능한 설계를 이끌어 내는 기반이 된다. 
				- 분해한 메서드는 각 메서드가 사용하는 데이터를 정의하는 클래스로 이동한다. 
					- 응집도가 높아지고 내부 구현을 확실하게 캡슐화할 수 있다. 
					- 불필요하게 내부구현을 노출시키는 모든  setter, getter 메서드를 제거할 수 있다. 

=> 실제로 처음부터 책임주도설계 과정 실습해보기
	
### 6. 메시지와 인터페이스

- 클래스라는 구현 도구에 지나치게 집착하면 경직되고 유연하지 못한 설계에 이를 확률이 높아진다.
- 객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 객체들이 주고 받는 메시지다.
- 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다. 
- 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다.
- 훌륭한 퍼블릭 인터페이스를 얻기 위해서는 책임 주도 설계 방법을 따르는 것만으로는 부족하다. 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설계 원칙과 기법을 익히고 적용해야한다. 
- 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정한다. 객체의 퍼블릭인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 할 수 있다.

##### 협력과 메시지
- 메시지와 메시지 전송
	- 객체는 협력에 참여하는 동안 클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적이다.
	- 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.  
	- 한 객체가 다른 객체에게 도움을 요청하는 것을 메시지 전송 또는 메시지 패싱이라고 부른다.
	- 메시지는 오퍼레이션명과 인자로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다. 
	- 메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려있다. 
- 메시지와 메서드
	- 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다. 
	- 코드상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다. 
	- 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다. 
	- 즉, 메시지 전송을 코드 상에 표기하는 시점에서는 어떤 코드가 실행될 것인지를 정확하게 알 수 없다. 실행 시점에 실제로 실행되는 코드는 메시지를 수신하는 객체의 타입에 따라 달라지기 때문에 우리는 그저 메시지에 응답할 수 있는 객체가 존재하고 그 객체가 적절한 메서드를 선택해서 응답할 것이라고 믿을 수 밖에 없다.
	- 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다.
	- 메시지 전송자와 메시지 수신자는 서로에 대한 상세한 정보를 알지 못한 채 단지 메시지라는 얇은 끈을 통해 연결된다. 
- 퍼블릭 인터페이스와 오퍼레이션
	- 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다.
	- 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 한다. 
	- 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다. 
		- 오퍼레이션은 수행 가능한 어떤 행동에 대한 추상화다. 
		- 흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다. 
	- 그에 비해 메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다.
	- 객체가 다른 객체에게 메시지를 전송하면 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고 메시지를 수신한 객체의 실제 타입을 기반으로 적절한 메서드를 찾아 실행한다.
- 시그니처
	- 오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처(signature)라고 부른다. 
	- 오퍼레이션 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것이라고 정의할 수 있다.

##### 인터페이스와 설계 품질
- 
- 
- 
- 
- 